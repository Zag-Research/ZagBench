----QUIT----2025-07-29T18:44:10.164384+02:00 Pharo13.0-SNAPSHOT-64bit-6103a275f1.image priorSource: 0!----QUIT----2025-07-29T18:44:10.164997+02:00 Pharo13.0-SNAPSHOT-64bit-6103a275f1.image priorSource: 0!----QUIT----2025-07-29T18:44:30.498624+02:00 Pharo13.0-SNAPSHOT-64bit-6103a275f1.image priorSource: 104!----QUIT----2025-07-29T18:44:30.499777+02:00 Pharo13.0-SNAPSHOT-64bit-6103a275f1.image priorSource: 208!----QUIT----2025-07-29T18:44:31.002689+02:00 Pharo13.0-SNAPSHOT-64bit-6103a275f1.image priorSource: 314!----QUIT----2025-07-29T18:44:31.003372+02:00 Pharo13.0-SNAPSHOT-64bit-6103a275f1.image priorSource: 420!!ManifestZagBench commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!BeDBPlan commentStamp: '' prior: 0!A Plan is an ordered list of constraints to be executed in sequence toresatisfy all currently satisfiable constraints in the face of one or morechanging inputs.!!BeBody commentStamp: '' prior: 0!The Computer Language Benchmarks Game  http://benchmarksgame.alioth.debian.org/  contributed by Mark C. Lewis  modified slightly by Chad Whipkey    Based on nbody.java ported to SOM by Stefan Marr.  See LICENSE.md file.!!BeDBAbstractConstraint commentStamp: '' prior: 0!I am an abstract class representing a system-maintainable relationship (or"constraint") between a set of variables. I supply a strength instancevariable; concrete subclasses provide a means of storing the constrainedvariables and other information required to represent a constraint.Instance variables:	strength			the strength of this constraint <BeDBStrength>!!BeDBBinaryConstraint commentStamp: '' prior: 0!I am an abstract superclass for constraints having two possible outputvariables.Instance variables:	v1, v2		possible output variables <BeDBVariable>	direction		one of:					#forward (v2 is output)					#backward (	v1 is output)					nil (not satisfied)!!BeDBEqualityConstraint commentStamp: '' prior: 0!I constrain two variables to have the same value: "v1 = v2".!!BeDBScaleConstraint commentStamp: '' prior: 0!I relate two variables by the linear scaling relationship:"v2 = (v1 * scale) + offset". Either v1 or v2 may be changed to maintain thisrelationship but the scale factor and offset are considered read-only.Instance variables:	scale		scale factor input variable <BeDBVariable>	offset		offset input variable <BeDBVariable>!!BeDBUnaryConstraint commentStamp: '' prior: 0!I am an abstract superclass for constraints having a single possible outputvariable.Instance variables:	output		possible output variable <BeDBVariable>	satisfied		true if I am currently satisfied <Boolean>!!BeDBEditConstraint commentStamp: '' prior: 0!I am a unary input constraint used to mark a variable that the clientwishes to change.!!BeDBStayConstraint commentStamp: '' prior: 0!I mark variables that should, with some level of preference, stay the same.I have one method with zero inputs and one output, which does nothing. Plannersmay exploit the fact that, if I am satisfied, my output will not change duringplan execution. This is called "stay optimization."!!BeDBStrength commentStamp: '' prior: 0!Strengths are used to measure the relative importance of constraints. Thehierarchy of available strengths is determined by the class variableStrengthTable (see my class initialization method). Because Strengths areinvariant, references to BeDBStrength instances are shared (i.e. all references to"BeDBStrength of: #required" point to a single, shared instance). New strengths maybe inserted in the strength hierarchy without disrupting current constraints.Instance variables:	symbolicValue		symbolic strength name (e.g. #required) <Symbol>	arithmeticValue		index of the constraint in the hierarchy, used for comparisons <Number>!!BeDBVariable commentStamp: '' prior: 0!I represent a constrained variable. In addition to my value, I maintain thestructure of the constraint graph, the current dataflow graph, and variousparameters of interest to the DeltaBlue incremental constraint solver.Instance variables:	value			my value; changed by constraints, read by client <Object>	constraints		normal constraints that reference me <Array of Constraint>	determinedBy	the constraint that currently determines					my value (or nil if there isn't one) <Constraint>	walkStrength		my walkabout strength <BeDBStrength>	stay			true if I am a planning-time constant <Boolean>	mark			used by the planner to mark constraints <Number>!!BeNBodySystem commentStamp: '' prior: 0!The Computer Language Benchmarks Game  http://shootout.alioth.debian.org/  contributed by Mark C. Lewis  modified slightly by Chad Whipkey  Based on nbody.java ported to SOM by Stefan Marr.  See LICENSE.md file.!!BeRandom commentStamp: '' prior: 0!I generate random integers in a repeatable way so that our "random" algorithms are repeatable.!!BeRichardsBenchmark commentStamp: '' prior: 0!I implement the Richards scheduling benchmark!!Benchmark commentStamp: '' prior: 0!Benchmark runner and superclassAll benchmarks should be subclasses of this.Run a benchmark doing something like:      `Benchmark` `NBody`or		`Benchmark` run: #NBodyIt will create an instance of the benchmark and send it an `innerBenchmarkLoop:` message to run the benchmark.The number of runs for that benchmark is the number returned by the class-side method `mainIterations`, which defaults to 10.The number of iterations for that method to run is the number returned by the class-side method `innerIterations`, which defaults to 250,000.A garbage collection is done before the first run, so depending on the benchmark, some variance may come from collection within individual runs.Statistics of execution are printed on the `Transcript`, including mean, standard deviation, and several other usefull values.All the values can be accessed from the run benchmark: `mean`, `stdDev`, `min`, `max`, `firstQuartile`, `median`, `thirdQuartile`, as well as the raw runtimes in `times`.Orginally based on https://github.com/smarr/are-we-fast-yet/blob/master/benchmarks/Smalltalk/Run.som which has the following copyright:Copyright (c) 2011-2016 see AUTHORS.md filePermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the 'Software'), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.!!BeDeltaBlue commentStamp: '' prior: 0!This benchmark is an implementation of the DeltaBlue Constraint Solverdescribed in `The DeltaBlue Algorithm: An Incremental ConstraintHierarchy Solver', by Bjorn N. Freeman-Benson and John Maloney,Communications of the ACM, January 1990 (also as University ofWashington TR 89-08-06). To run the benchmark, execute the expression `BeDBPlanner standardBenchmark'.!!BeMandelbrot commentStamp: '' prior: 0!I implement a Mandelbrot benchmarkI test floating point operations (mostly addition and multiplications, with a few divisions) with a triply-nested loop.Derived from https://github.com/smarr/are-we-fast-yet/blob/master/benchmarks/Smalltalk/Mandelbrot.som!!BeNBody commentStamp: '' prior: 0!The Computer Language Benchmarks Game  http://shootout.alioth.debian.org/  contributed by Mark C. Lewis  modified slightly by Chad Whipkey    Based on nbody.java ported to SOM by Stefan Marr.  See LICENSE.md file.Ported from SOM at https://github.com/smarr/are-we-fast-yet/tree/master!!BeQueens commentStamp: '' prior: 0!I implement the classic N-Queens problem!!BeSieve commentStamp: '' prior: 0!Classic Sieve of Eratosthenes banchmarkI test integer and array with a doubly-nested loop.Derived from https://github.com/smarr/are-we-fast-yet/blob/master/benchmarks/Smalltalk/Sieve.som!!ThreadSafeTranscript methodsFor: '*ZagBench' stamp: '2025-08-02T22:54:44.049-04:00'!<<< anObject	anObject printOrPutOn: self! !!ThreadSafeTranscript methodsFor: '*ZagBench' stamp: '2025-08-02T22:54:44.05-04:00'!print: aNumber withDecimaPlaces: anInteger	aNumber printOn: self showingDecimalPlaces: anInteger! !!ThreadSafeTranscript methodsFor: '*ZagBench' stamp: '2025-08-02T22:54:44.051-04:00'!println: aString 	self show: aString;cr! !!String methodsFor: '*ZagBench' stamp: '2025-08-02T22:54:44.051-04:00'!printOrPutOn: aStream	aStream nextPutAll: self! !!ManifestZagBench class methodsFor: 'code-critics' stamp: '2025-08-02T22:54:44.056-04:00'!ruleClassNotReferencedRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGPackageDefinition #(#ZagBench)) #'2024-09-10T15:18:28.185408-04:00') )! !!ManifestZagBench class methodsFor: 'code-critics' stamp: '2025-08-02T22:54:44.057-04:00'!ruleLongMethodsRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGPackageDefinition #(#ZagBench)) #'2024-07-31T13:53:20.583848-04:00') )! !!ManifestZagBench class methodsFor: 'code-critics' stamp: '2025-08-02T22:54:44.057-04:00'!ruleReCyclomaticComplexityRuleV1FalsePositive	<ignoreForCoverage>	^ #( #( #( #RGPackageDefinition #( #ZagBench ) )	        #'2024-09-10T15:01:12.769636-04:00' ) )! !!ManifestZagBench class methodsFor: 'code-critics' stamp: '2025-08-02T22:54:44.057-04:00'!ruleRefersToClassRuleV1FalsePositive	<ignoreForCoverage>	^ #(#(#(#RGMethodDefinition #(#'Benchmark class' #run #true)) #'2024-08-01T09:49:37.471071-04:00') )! !!ManifestZagBench class methodsFor: 'code-critics' stamp: '2025-08-02T22:54:44.057-04:00'!ruleWhileTrueRuleV1FalsePositive	<ignoreForCoverage>	^ #( #( #( #RGPackageDefinition #( #ZagBench ) )	        #'2024-09-10T15:01:22.027308-04:00' ) )! !!BenchRandomTest methodsFor: 'running' stamp: '2025-08-02T22:54:44.058-04:00'!setUp	super setUp.	gen := BeRandom new! !!BenchRandomTest methodsFor: 'tests' stamp: '2025-08-02T22:54:44.06-04:00'!testDistribution	| results occurrences |	1 to: 100 do: [ :i |		results := Bag new.		2000 timesRepeat: [ results add: (gen nextInteger: 100) ].		occurrences := Array new: 100 streamContents: [ :out |			               results doWithOccurrences: [ :element :occurrence |				               self assert: (element between: 1 and: 100).				               out nextPut: occurrence				               "self assert: (occurrence between: 5 and: 40)" ] ].		self assert: occurrences average equals: 2000. "20"		self assert: occurrences stdev < 10 ]! !!BenchRandomTest methodsFor: 'tests' stamp: '2025-08-02T22:54:44.06-04:00'!testNext	10000 timesRepeat: [		| next |		next := gen next.		self assert: next >= 0.		self assert: next < 1 ]! !!BeDBPlan methodsFor: 'execution' stamp: '2025-08-02T22:54:44.06-04:00'!execute	"Execute my constraints in order."	self do: [: c | c execute].! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.06-04:00'!DaysPerYear	^ 365.24! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.061-04:00'!Pi	^ 3.141592653589793! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.061-04:00'!SolarMass	^ solarMass! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.061-04:00'!initialize	solarMass := 4 * self Pi * self Pi! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.061-04:00'!jupiter     ^ self new         initX:    4.8414314424647209             y:   -1.16032004402742839             z:   -0.103622044471123109             vx:   0.00166007664274403694             vy:   0.00769901118419740425             vz:  -0.0000690460016972063023             mass: 0.000954791938424326609! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.062-04:00'!neptune    ^ self new        initX:   15.3796971148509165            y:  -25.9193146099879641            z:    0.179258772950371181            vx:   0.00268067772490389322            vy:   0.00162824170038242295            vz:  -0.000095159225451971587            mass: 0.0000515138902046611451! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.062-04:00'!saturn    ^ self new        initX:    8.34336671824457987            y:    4.12479856412430479            z:   -0.403523417114321381            vx:  -0.00276742510726862411            vy:   0.00499852801234917238            vz:   0.0000230417297573763929            mass: 0.000285885980666130812! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.062-04:00'!sun    ^ self new initX: 0.0 y: 0.0 z: 0.0 vx: 0.0 vy: 0.0 vz: 0.0 mass: 1.0! !!BeBody class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.062-04:00'!uranus    ^ self new        initX:   12.894369562139131            y:  -15.1111514016986312            z:   -0.223307578892655734            vx:   0.00296460137564761618            vy:   0.0023784717395948095            vz:  -0.0000296589568540237556            mass: 0.0000436624404335156298! !!BeBody methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.063-04:00'!initX: anX y: aY z: aZ vx: aVX vy: aVY vz: aVZ mass: aMass    x := anX.    y := aY.    z := aZ.    vx := aVX * BeBody DaysPerYear.    vy := aVY * BeBody DaysPerYear.    vz := aVZ * BeBody DaysPerYear.    mass := aMass * BeBody SolarMass! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.063-04:00'!mass	^ mass! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.063-04:00'!mass: anObject	mass := anObject! !!BeBody methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.063-04:00'!offsetMomentumX: px y: py z: pz    vx := 0.0 - (px / BeBody SolarMass).    vy := 0.0 - (py / BeBody SolarMass).    vz := 0.0 - (pz / BeBody SolarMass)! !!BeBody methodsFor: 'printing' stamp: '2025-08-02T22:54:44.063-04:00'!print    'x:  ' print. x println.    'y:  ' print. y println.    'z:  ' print. z println.        'vx: ' print. vx println.    'vy: ' print. vy println.    'vz: ' print. vz println.        'mass: ' print. mass println! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.063-04:00'!vx	^ vx! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.063-04:00'!vx: anObject	vx := anObject! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.064-04:00'!vy	^ vy! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.064-04:00'!vy: anObject	vy := anObject! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.064-04:00'!vz	^ vz! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.064-04:00'!vz: anObject	vz := anObject! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.064-04:00'!x	^ x! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.064-04:00'!x: anObject	x := anObject! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.064-04:00'!y	^ y! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.064-04:00'!y: anObject	y := anObject! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.066-04:00'!z	^ z! !!BeBody methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.066-04:00'!z: anObject	z := anObject! !!BeDBAbstractConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.066-04:00'!addConstraint	"Activate this constraint and attempt to satisfy it."	self addToGraph.	BeDeltaBlue current incrementalAdd: self.! !!BeDBAbstractConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.066-04:00'!addToGraph	"Add myself to the constraint graph."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.066-04:00'!chooseMethod: mark	"Decide if I can be satisfied and record that decision. The output of	 the choosen method must not have the given mark and must have a	 walkabout strength less than that of this constraint."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.066-04:00'!destroyConstraint	"Deactivate this constraint, remove it from the constraint graph,	 possibly causing other constraints to be satisfied, and destroy it."	(self isSatisfied) ifTrue: [BeDeltaBlue current incrementalRemove: self].	self removeFromGraph.	self release.! !!BeDBAbstractConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.066-04:00'!execute	"Enforce this constraint. Assume that it is satisfied."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.067-04:00'!inputsDo: aBlock	"Assume that I am satisfied. Evaluate the given block on all my current	 input variables."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.067-04:00'!inputsKnown: mark	"Assume that I am satisfied. Answer true if all my current inputs are	 known. A variable is known if either a) it is 'stay' (i.e. it is a	 constant at plan execution time), b) it has the given mark (indicating	 that it has been computed by a constraint appearing earlier in the	 plan), or c) it is not determined by any constraint."	self inputsDo:		[: v |		 ((v mark = mark) or: [(v stay) or: [v determinedBy == nil]]) ifFalse:			[^false]].	^true! !!BeDBAbstractConstraint methodsFor: 'queries' stamp: '2025-08-02T22:54:44.067-04:00'!isInput	"Normal constraints are not input constraints. An input constraint is	 one that depends on external state, such as the mouse, the keyboard,	 a clock, or some arbitrary piece of imperative code."	^false! !!BeDBAbstractConstraint methodsFor: 'queries' stamp: '2025-08-02T22:54:44.067-04:00'!isSatisfied	"Answer true if this constraint is satisfied in the current solution."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'printing' stamp: '2025-08-02T22:54:44.068-04:00'!longPrintOn: aStream	| bindings |	aStream nextPut: $(.	self shortPrintOn: aStream.	aStream space; nextPutAll: self strength printString.	(self isSatisfied)		ifTrue:			[aStream cr; space; space; space.			 self inputsDo:				[: in | aStream nextPutAll: 'v', in asOop printString, ' '].			aStream nextPutAll: '-> '.			aStream nextPutAll: 'v', self output asOop printString]		ifFalse:			[aStream space; nextPutAll: 'UNSATISFIED'].	aStream nextPut: $); cr.! !!BeDBAbstractConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.068-04:00'!markUnsatisfied	"Record the fact that I am unsatisfied."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.068-04:00'!output	"Answer my current output variable. Raise an error if I am not	 currently satisfied."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'printing' stamp: '2025-08-02T22:54:44.068-04:00'!printOn: aStream	self shortPrintOn: aStream! !!BeDBAbstractConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.069-04:00'!recalculate	"Calculate the walkabout strength, the stay flag, and, if it is 'stay',	 the value for the current output of this constraint. Assume this	 constraint is satisfied."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.069-04:00'!removeFromGraph	"Remove myself from the constraint graph."	self subclassResponsibility! !!BeDBAbstractConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.069-04:00'!satisfy: mark	"Attempt to find a way to enforce this (still unsatisfied) constraint.	 If successful, record the solution, perhaps modifying the current	 dataflow graph.  Answer the constraint that this constraint overrides,	 if there is one, or nil, if there isn't."	| overridden out |	self chooseMethod: mark.	(self isSatisfied)		ifTrue:			"constraint can be satisfied"			["mark inputs to allow cycle detection in addPropagate"			 self inputsDo: [: in | in mark: mark].			 out := self output.			 overridden := out determinedBy.			 (overridden == nil) ifFalse: [overridden markUnsatisfied].			 out determinedBy: self.			 (BeDeltaBlue current addPropagate: self mark: mark) ifFalse:				[self notify:					('Cycle encountered adding:\   ',					 self printString,					 '\Constraint removed.') withCRs.				 ^nil].			 out mark: mark]		ifFalse:			"constraint cannot be satisfied"			[overridden := nil.			 (strength sameAs: (BeDBStrength required)) ifTrue:				[self notify: 'Failed to satisfy a required constraint']].	^overridden! !!BeDBAbstractConstraint methodsFor: 'printing' stamp: '2025-08-02T22:54:44.07-04:00'!shortPrintOn: aStream	aStream nextPutAll: self class name, '(', self asOop printString, ')'.! !!BeDBAbstractConstraint methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.07-04:00'!strength	"Answer my strength."	^strength! !!BeDBAbstractConstraint methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.07-04:00'!strength: strengthSymbol	"Set my strength."	strength := BeDBStrength of: strengthSymbol.! !!BeDBBinaryConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.07-04:00'!addToGraph	"Add myself to the constraint graph."	v1 addConstraint: self.	v2 addConstraint: self.	direction := nil.! !!BeDBBinaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.071-04:00'!chooseMethod: mark	"Decide if I can be satisfied and which way I should flow based on	 the relative strength of the variables I relate, and record that	 decision."	(v1 mark == mark) ifTrue:		"forward or nothing"		[((v2 mark ~= mark) and: [strength stronger: v2 walkStrength])			ifTrue: [^direction := #forward]			ifFalse: [^direction := nil]].	(v2 mark == mark) ifTrue:		"backward or nothing"		[((v1 mark ~= mark) and: [strength stronger: v1 walkStrength])			ifTrue: [^direction := #backward]			ifFalse: [^direction := nil]].	"if we get here, neither variable is marked, so we have choice"	(v1 walkStrength weaker: v2 walkStrength)		ifTrue:			[(strength stronger: v1 walkStrength)				ifTrue: [^direction := #backward]				ifFalse: [^direction := nil]]		ifFalse:			[(strength stronger: v2 walkStrength)				ifTrue: [^direction := #forward]				ifFalse: [^direction := nil]].! !!BeDBBinaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.071-04:00'!execute	"Enforce this constraint. Assume that it is satisfied."	self subclassResponsibility! !!BeDBBinaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.071-04:00'!inputsDo: aBlock	"Evaluate the given block on my current input variable."	(direction == #forward)		ifTrue: [aBlock value: v1]		ifFalse: [aBlock value: v2].! !!BeDBBinaryConstraint methodsFor: 'queries' stamp: '2025-08-02T22:54:44.072-04:00'!isSatisfied	"Answer true if this constraint is satisfied in the current solution."	^direction notNil! !!BeDBBinaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.072-04:00'!markUnsatisfied	"Record the fact that I am unsatisfied."	direction := nil.! !!BeDBBinaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.072-04:00'!output	"Answer my current output variable."	(direction == #forward)		ifTrue: [^v2]		ifFalse: [^v1]! !!BeDBBinaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.072-04:00'!recalculate	"Calculate the walkabout strength, the stay flag, and, if it is 'stay',         the value for the current output of this constraint. Assume this	 constraint is satisfied."	| in out |	(direction == #forward)		ifTrue: [in := v1. out := v2]		ifFalse: [in := v2. out := v1].	out walkStrength: (strength weakest: in walkStrength).	out stay: (in stay).	(out stay) ifTrue: [self execute].		"stay optimization"! !!BeDBBinaryConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.072-04:00'!removeFromGraph	"Remove myself from the constraint graph."	(v1 == nil) ifFalse: [v1 removeConstraint: self].	(v2 == nil) ifFalse: [v2 removeConstraint: self].	direction := nil.! !!BeDBBinaryConstraint methodsFor: 'initialize-release' stamp: '2025-08-02T22:54:44.073-04:00'!var: variable1 var: variable2 strength: strengthSymbol	"Initialize myself with the given variables and strength."	strength := BeDBStrength of: strengthSymbol.	v1 := variable1.	v2 := variable2.	direction := nil.	self addConstraint.! !!BeDBEqualityConstraint class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.073-04:00'!var: variable1 var: variable2 strength: strengthSymbol	"Install a constraint with the given strength equating the given	 variables."	^(self new) var: variable1 var: variable2 strength: strengthSymbol! !!BeDBEqualityConstraint methodsFor: 'execution' stamp: '2025-08-02T22:54:44.073-04:00'!execute	"Enforce this constraint. Assume that it is satisfied."	(direction == #forward)		ifTrue: [v2 value: v1 value]		ifFalse: [v1 value: v2 value].! !!BeDBScaleConstraint class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.073-04:00'!var: src var: scale var: offset var: dst strength: strengthSymbol	"Install a scale constraint with the given strength on the given	 variables."	^(self new) src: src scale: scale offset: offset dst: dst strength: strengthSymbol! !!BeDBScaleConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.073-04:00'!addToGraph	"Add myself to the constraint graph."	v1 addConstraint: self.	v2 addConstraint: self.	scale addConstraint: self.	offset addConstraint: self.	direction := nil.! !!BeDBScaleConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.073-04:00'!execute	"Enforce this constraint. Assume that it is satisfied."	(direction == #forward)		ifTrue: [v2 value: (v1 value * scale value) + offset value]		ifFalse: [v1 value: (v2 value - offset value) // scale value].! !!BeDBScaleConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.073-04:00'!inputsDo: aBlock	"Evaluate the given block on my current input variable."	(direction == #forward)		ifTrue: [aBlock value: v1; value: scale; value: offset]		ifFalse: [aBlock value: v2; value: scale; value: offset].! !!BeDBScaleConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.075-04:00'!recalculate	"Calculate the walkabout strength, the stay flag, and, if it is 'stay',	 the value for the current output of this constraint. Assume this	 constraint is satisfied."	| in out |	(direction == #forward)		ifTrue: [in := v1. out := v2]		ifFalse: [out := v1. in := v2].	out walkStrength: (strength weakest: in walkStrength).	out stay: ((in stay) and: [(scale stay) and: [offset stay]]).	(out stay) ifTrue: [self execute].		"stay optimization"! !!BeDBScaleConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.075-04:00'!removeFromGraph	"Remove myself from the constraint graph."	(v1 == nil) ifFalse: [v1 removeConstraint: self].	(v2 == nil) ifFalse: [v2 removeConstraint: self].	(scale == nil) ifFalse: [scale removeConstraint: self].	(offset == nil) ifFalse: [offset removeConstraint: self].	direction := nil.! !!BeDBScaleConstraint methodsFor: 'initialize-release' stamp: '2025-08-02T22:54:44.076-04:00'!src: srcVar scale: scaleVar offset: offsetVar dst: dstVar strength: strengthSymbol	"Initialize myself with the given variables and strength."	strength := BeDBStrength of: strengthSymbol.	v1 := srcVar.	v2 := dstVar.	scale := scaleVar.	offset := offsetVar.	direction := nil.	self addConstraint.! !!BeDBEditConstraint class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.076-04:00'!var: aVariable strength: strengthSymbol	"Install an edit constraint with the given strength on the given	 variable."	^(self new) var: aVariable strength: strengthSymbol! !!BeDBEditConstraint methodsFor: 'execution' stamp: '2025-08-02T22:54:44.076-04:00'!execute	"Edit constraints do nothing."! !!BeDBEditConstraint methodsFor: 'queries' stamp: '2025-08-02T22:54:44.076-04:00'!isInput	"I indicate that a variable is to be changed by imperative code."	^true! !!BeDBStayConstraint class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.076-04:00'!var: aVariable strength: strengthSymbol	"Install a stay constraint with the given strength on the given variable."	^(self new) var: aVariable strength: strengthSymbol! !!BeDBStayConstraint methodsFor: 'execution' stamp: '2025-08-02T22:54:44.076-04:00'!execute	"Stay constraints do nothing."! !!BeDBUnaryConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.076-04:00'!addToGraph	"Add myself to the constraint graph."	output addConstraint: self.	satisfied := false.! !!BeDBUnaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.077-04:00'!chooseMethod: mark	"Decide if I can be satisfied and record that decision."	satisfied :=		(output mark ~= mark) and:		[strength stronger: output walkStrength].! !!BeDBUnaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.077-04:00'!execute	"Enforce this constraint. Assume that it is satisfied."	self subclassResponsibility! !!BeDBUnaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.077-04:00'!inputsDo: aBlock	"I have no input variables."! !!BeDBUnaryConstraint methodsFor: 'queries' stamp: '2025-08-02T22:54:44.077-04:00'!isSatisfied	"Answer true if this constraint is satisfied in the current solution."	^satisfied! !!BeDBUnaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.077-04:00'!markUnsatisfied	"Record the fact that I am unsatisfied."	satisfied := false.! !!BeDBUnaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.077-04:00'!output	"Answer my current output variable."	^output! !!BeDBUnaryConstraint methodsFor: 'planning' stamp: '2025-08-02T22:54:44.077-04:00'!recalculate	"Calculate the walkabout strength, the stay flag, and, if it is 'stay',	 the value for the current output of this constraint. Assume this	 constraint is satisfied."	output walkStrength: strength.	output stay: (self isInput not).	(output stay) ifTrue: [self execute].	"stay optimization"! !!BeDBUnaryConstraint methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.077-04:00'!removeFromGraph	"Remove myself from the constraint graph."	(output == nil) ifFalse: [output removeConstraint: self].	satisfied := false.! !!BeDBUnaryConstraint methodsFor: 'initialize-release' stamp: '2025-08-02T22:54:44.078-04:00'!var: aVariable strength: strengthSymbol	"Initialize myself with the given variable and strength."	strength := BeDBStrength of: strengthSymbol.	output := aVariable.	satisfied := false.	self addConstraint.! !!BeDBStrength class methodsFor: 'constants' stamp: '2025-08-02T22:54:44.078-04:00'!absoluteStrongest	^AbsoluteStrongest! !!BeDBStrength class methodsFor: 'constants' stamp: '2025-08-02T22:54:44.078-04:00'!absoluteWeakest	^AbsoluteWeakest! !!BeDBStrength class methodsFor: 'class initialization' stamp: '2025-08-02T22:54:44.078-04:00'!initialize	"Initialize the symbolic strength table. Fix the internally caches	 values of all existing instances."	"BeDBStrength initialize"	StrengthTable := Dictionary new.	StrengthTable at: #absoluteStrongest put: -10000.	StrengthTable at: #required put: -800.	StrengthTable at: #strongPreferred put: -600.	StrengthTable at: #preferred put: -400.	StrengthTable at: #strongDefault put: -200.	StrengthTable at: #default put: 0.	StrengthTable at: #weakDefault put: 500.	StrengthTable at: #absoluteWeakest put: 10000.	StrengthConstants := Dictionary new.	StrengthTable keys do:		[: strengthSymbol |			StrengthConstants				at: strengthSymbol				put: ((super new) initializeWith: strengthSymbol)].	AbsoluteStrongest := BeDBStrength of: #absoluteStrongest.	AbsoluteWeakest := BeDBStrength of: #absoluteWeakest.	Required := BeDBStrength of: #required.! !!BeDBStrength class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.079-04:00'!of: aSymbol	"Answer an instance with the specified strength."	^StrengthConstants at: aSymbol! !!BeDBStrength class methodsFor: 'constants' stamp: '2025-08-02T22:54:44.079-04:00'!required	^Required! !!BeDBStrength methodsFor: 'private' stamp: '2025-08-02T22:54:44.082-04:00'!arithmeticValue	"Answer my arithmetic value. Used for comparisons. Note that	 STRONGER constraints have SMALLER arithmetic values."	^arithmeticValue! !!BeDBStrength methodsFor: 'private' stamp: '2025-08-02T22:54:44.083-04:00'!initializeWith: symVal	"Record my symbolic value and reset my arithmetic value."	symbolicValue := symVal.	arithmeticValue := StrengthTable at: symbolicValue.! !!BeDBStrength methodsFor: 'printing' stamp: '2025-08-02T22:54:44.083-04:00'!printOn: aStream	"Append a string which represents my strength onto aStream."	aStream nextPutAll: '%', symbolicValue, '%'.! !!BeDBStrength methodsFor: 'comparing' stamp: '2025-08-02T22:54:44.083-04:00'!sameAs: aStrength	"Answer true if I am the same strength as the given BeDBStrength."	^arithmeticValue = aStrength arithmeticValue! !!BeDBStrength methodsFor: 'comparing' stamp: '2025-08-02T22:54:44.083-04:00'!stronger: aStrength	"Answer true if I am stronger than the given BeDBStrength."	^arithmeticValue < aStrength arithmeticValue! !!BeDBStrength methodsFor: 'max/min' stamp: '2025-08-02T22:54:44.084-04:00'!strongest: aStrength	"Answer the stronger of myself and aStrength."	(aStrength stronger: self)		ifTrue: [^aStrength]		ifFalse: [^self].! !!BeDBStrength methodsFor: 'comparing' stamp: '2025-08-02T22:54:44.084-04:00'!weaker: aStrength	"Answer true if I am weaker than the given BeDBStrength."	^arithmeticValue > aStrength arithmeticValue! !!BeDBStrength methodsFor: 'max/min' stamp: '2025-08-02T22:54:44.084-04:00'!weakest: aStrength	"Answer the weaker of myself and aStrength."	(aStrength weaker: self)		ifTrue: [^aStrength]		ifFalse: [^self].! !!BeDBVariable class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.084-04:00'!new	^super new initialize! !!BeDBVariable class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.085-04:00'!value: aValue	^(super new) initialize; value: aValue! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.085-04:00'!addConstraint: aConstraint	"Add the given constraint to the set of all constraints that refer	 to me."	constraints add: aConstraint.! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.085-04:00'!constraints	"Answer the set of constraints that refer to me."	^constraints! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.085-04:00'!determinedBy	"Answer the constraint that determines my value in the current	 dataflow."	^determinedBy! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.085-04:00'!determinedBy: aConstraint	"Record that the given constraint determines my value in the current	 data flow."	determinedBy := aConstraint.! !!BeDBVariable methodsFor: 'initialize-release' stamp: '2025-08-02T22:54:44.085-04:00'!initialize	value := 0.	constraints := OrderedCollection new: 2.	determinedBy := nil.	walkStrength := BeDBStrength absoluteWeakest.	stay := true.	mark := 0.! !!BeDBVariable methodsFor: 'printing' stamp: '2025-08-02T22:54:44.086-04:00'!longPrintOn: aStream	self shortPrintOn: aStream.	aStream nextPutAll: '   Constraints: '.	(constraints isEmpty)		ifTrue: [aStream cr; tab; nextPutAll: 'none']		ifFalse:			[constraints do:				[: c | aStream cr; tab. c shortPrintOn: aStream]].	(determinedBy isNil) ifFalse:		[aStream cr; nextPutAll: '   Determined by: '.		 aStream cr; tab. determinedBy shortPrintOn: aStream].	aStream cr.! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.086-04:00'!mark	"Answer my mark value."	^mark! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.086-04:00'!mark: markValue	"Set my mark value."	mark := markValue.! !!BeDBVariable methodsFor: 'printing' stamp: '2025-08-02T22:54:44.086-04:00'!printOn: aStream	self shortPrintOn: aStream! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.087-04:00'!removeConstraint: c	"Remove all traces of c from this variable."	constraints remove: c ifAbsent: [].	(determinedBy == c) ifTrue: [determinedBy := nil].! !!BeDBVariable methodsFor: 'changes' stamp: '2025-08-02T22:54:44.087-04:00'!setValue: aValue	"Attempt to assign the given value to me using a strength of	 #preferred."	self setValue: aValue strength: #preferred.! !!BeDBVariable methodsFor: 'changes' stamp: '2025-08-02T22:54:44.087-04:00'!setValue: aValue strength: strengthSymbol	"Attempt to assign the given value to me using the given strength."	| editConstraint |	editConstraint := BeDBEditConstraint var: self strength: strengthSymbol.	(editConstraint isSatisfied) ifTrue:		[self value: aValue.		 BeDeltaBlue propagateFrom: self].	editConstraint destroyConstraint.! !!BeDBVariable methodsFor: 'printing' stamp: '2025-08-02T22:54:44.088-04:00'!shortPrintOn: aStream	aStream nextPutAll: 'V(', self asOop printString, ', '.	aStream nextPutAll: walkStrength printString, ', '.	(stay isNil) ifFalse:		[aStream nextPutAll: (stay ifTrue: ['stay, '] ifFalse: ['changing, '])].	aStream nextPutAll: value printString.	aStream nextPutAll: ')'.	aStream cr.! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.088-04:00'!stay	"Answer my stay flag."	^stay! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.088-04:00'!stay: aBoolean	"Set my stay flag."	stay := aBoolean! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.088-04:00'!value	"Answer my value."	^value! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.088-04:00'!value: anObject	"Set my value."	value := anObject.! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.088-04:00'!walkStrength	"Answer my walkabout strength in the current dataflow."	^walkStrength! !!BeDBVariable methodsFor: 'access' stamp: '2025-08-02T22:54:44.09-04:00'!walkStrength: aStrength	"Set my walkabout strength in the current dataflow."	walkStrength := aStrength.! !!BeNBodySystem methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.091-04:00'!advance: dt    1 to: bodies size do: [:i |      | iBody |      iBody := bodies at: i.      i + 1 to: bodies size do: [:j |        | dx dy dz jBody dSquared distance mag |        jBody := bodies at: j.        dx := iBody x - jBody x.        dy := iBody y - jBody y.        dz := iBody z - jBody z.        dSquared := (dx * dx) + (dy * dy) + (dz * dz).        distance := dSquared sqrt.        mag      := dt / (dSquared * distance).        iBody vx: iBody vx - (dx * jBody mass * mag).        iBody vy: iBody vy - (dy * jBody mass * mag).        iBody vz: iBody vz - (dz * jBody mass * mag).        jBody vx: jBody vx + (dx * iBody mass * mag).        jBody vy: jBody vy + (dy * iBody mass * mag).        jBody vz: jBody vz + (dz * iBody mass * mag).      ].    ].    bodies do: [:body |       body x: body x + (dt * body vx).       body y: body y + (dt * body vy).       body z: body z + (dt * body vz).    ]! !!BeNBodySystem methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.093-04:00'!createBodies    | px py pz |    bodies := Array new: 5.    bodies at: 1 put: BeBody sun.    bodies at: 2 put: BeBody jupiter.    bodies at: 3 put: BeBody saturn.    bodies at: 4 put: BeBody uranus.    bodies at: 5 put: BeBody neptune.    "bodies do: [:b | b print. '' println ]."    px := 0.0.  py := 0.0.  pz := 0.0.    bodies do: [:b |        px := px + (b vx * b mass).        py := py + (b vy * b mass).        pz := pz + (b vz * b mass).    ].    (bodies at: 1) offsetMomentumX: px y: py z: pz.    "bodies do: [:b | b print. '' println ]."! !!BeNBodySystem methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.094-04:00'!energy    | e |    e := 0.0.    1 to: bodies size do: [:i |      | iBody |      iBody := bodies at: i.      e := e + (0.5 * iBody mass *           ((iBody vx * iBody vx) +            (iBody vy * iBody vy) +            (iBody vz * iBody vz))).      i + 1 to: bodies size do: [:j |          | jBody dx dy dz distance |          jBody := bodies at: j.          dx := iBody x - jBody x.          dy := iBody y - jBody y.          dz := iBody z - jBody z.          distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.          e := e - ((iBody mass * jBody mass) / distance).      ].    ].    ^ e! !!BeNBodySystem methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.095-04:00'!initialize    self createBodies"testing"! !!BeRandom methodsFor: 'random value creation' stamp: '2025-08-02T22:54:44.095-04:00'!between: low and: high	"Answer a random integer in the interval [1, anInteger].	Handle large numbers too (for cryptography)."	^ (self next * (high - low + 1)) truncated + low! !!BeRandom methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.096-04:00'!initialize	super initialize.	rand := 12345. "Choose an initial seed value"	multiplier := 1103515245. "Multiplier constant"	increment := 12345. "Increment constant"	modulus := 2 raisedTo: 31. "Modulus "	scale := 1.0 / modulus asFloat! !!BeRandom methodsFor: 'random value creation' stamp: '2025-08-02T22:54:44.096-04:00'!makeInvertable: size	^ (self randomSquare: size) withIndexDo: [ :row :index |		row			at: index			put: (row inject: 0 into: [ :sum :each | sum + each abs ]) ];		yourself! !!BeRandom methodsFor: 'random value creation' stamp: '2025-08-02T22:54:44.096-04:00'!next	rand := multiplier * rand + increment \\ modulus . "Linear congruential generator formula"	^ rand * scale! !!BeRandom methodsFor: 'random value creation' stamp: '2025-08-02T22:54:44.097-04:00'!nextInteger: anInteger	"Answer a random integer in the interval [1, anInteger].	Handle large numbers too (for cryptography)."	anInteger strictlyPositive ifFalse: [		self error: 'Range must be positive' ].	^ (self next * anInteger) truncated	  + 1! !!BeRandom methodsFor: 'random value creation' stamp: '2025-08-02T22:54:44.097-04:00'!randomSquare: anInteger	^ self randomWithRows: anInteger columns: anInteger! !!BeRandom methodsFor: 'random value creation' stamp: '2025-08-02T22:54:44.097-04:00'!randomWithRows: rows columns: cols	^ (1 to: rows) collect: [ :i |		  (1 to: cols) collect: [ :j | self next ] ]! !!BeRiDeviceTaskDataRecord class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.097-04:00'!create    ^super new create! !!BeRiDeviceTaskDataRecord methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.097-04:00'!create    pending := nil! !!BeRiDeviceTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.097-04:00'!pending    ^pending! !!BeRiDeviceTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.097-04:00'!pending: packet     pending := packet! !!BeRiHandlerTaskDataRecord class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.098-04:00'!create    ^super new create! !!BeRiHandlerTaskDataRecord methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.098-04:00'!create    workIn := deviceIn := nil! !!BeRiHandlerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.098-04:00'!deviceIn    ^deviceIn! !!BeRiHandlerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.098-04:00'!deviceIn: aPacket    deviceIn := aPacket! !!BeRiHandlerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.098-04:00'!deviceInAdd: packet    deviceIn := self append: packet head: deviceIn! !!BeRiHandlerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.098-04:00'!workIn    ^workIn! !!BeRiHandlerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.098-04:00'!workIn: aWorkQueue     workIn := aWorkQueue! !!BeRiHandlerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.098-04:00'!workInAdd: packet    workIn := self append: packet head: workIn! !!BeRiIdleTaskDataRecord class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.098-04:00'!create    ^super new create! !!BeRiIdleTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.098-04:00'!control    ^control! !!BeRiIdleTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.099-04:00'!control: aNumber    control := aNumber! !!BeRiIdleTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.099-04:00'!count    ^count! !!BeRiIdleTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.099-04:00'!count: aCount    count := aCount! !!BeRiIdleTaskDataRecord methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.099-04:00'!create    control := 1.    count := 10000! !!BeRiObject class methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.099-04:00'!initialize    "BeRiObject initialize"    DeviceA := 5.    DeviceB := 6.    DevicePacketKind := 1.    HandlerA := 3.    HandlerB := 4.    Idler := 1.    Worker := 2.    WorkPacketKind := 2! !!BeRiObject methodsFor: 'utilities' stamp: '2025-08-02T22:54:44.099-04:00'!append: packet head: queueHead    | mouse link |    packet link: nil.    queueHead isNil ifTrue: [^packet].    mouse := queueHead.    [(link := mouse link) isNil]	whileFalse: [mouse := link].    mouse link: packet.    ^queueHead! !!BeRiPacket class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.101-04:00'!create: link identity: identity kind: kind     ^super new	link: link	identity: identity	kind: kind! !!BeRiPacket methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.101-04:00'!data    ^data! !!BeRiPacket methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.101-04:00'!datum    ^datum! !!BeRiPacket methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.101-04:00'!datum:    someData    datum := someData! !!BeRiPacket methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.101-04:00'!identity    ^identity! !!BeRiPacket methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.101-04:00'!identity: anIdentity    identity := anIdentity! !!BeRiPacket methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.101-04:00'!kind    ^kind! !!BeRiPacket methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.101-04:00'!link    ^link! !!BeRiPacket methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.101-04:00'!link: aWorkQueue     link := aWorkQueue! !!BeRiPacket methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.101-04:00'!link: aLink identity: anIdentity kind: aKind     link := aLink.    identity := anIdentity.     kind := aKind.    datum := 1.    data := ByteArray new: 4! !!BeRiTaskControlBlock class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.102-04:00'!link: link create: identity priority: priority initialWorkQueue: initialWorkQueue initialState: initialState function: aBlock privateData: privateData     ^super new	link: link	identity: identity	priority: priority	initialWorkQueue: initialWorkQueue	initialState: initialState	function: aBlock	privateData: privateData! !!BeRiTaskControlBlock methodsFor: 'scheduling' stamp: '2025-08-02T22:54:44.102-04:00'!addInput: packet checkPriority: oldTask    input isNil	ifTrue: 	    [input := packet.	    packetPendingIV := true.	    priority > oldTask priority ifTrue: [^self]]	ifFalse: 	    [input := self append: packet head: input].    ^oldTask! !!BeRiTaskControlBlock methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.102-04:00'!identity    ^identity! !!BeRiTaskControlBlock methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.102-04:00'!link    ^link! !!BeRiTaskControlBlock methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.102-04:00'!link: aLink identity: anIdentity priority: aPriority initialWorkQueue: anInitialWorkQueue initialState: anInitialState function: aBlock privateData: aPrivateData     link := aLink.    identity := anIdentity.    priority := aPriority.    input := anInitialWorkQueue.    packetPendingIV := anInitialState isPacketPending.    taskWaiting := anInitialState isTaskWaiting.    taskHolding := anInitialState isTaskHolding.    function := aBlock.    handle := aPrivateData! !!BeRiTaskControlBlock methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.103-04:00'!priority    ^priority! !!BeRiTaskControlBlock methodsFor: 'scheduling' stamp: '2025-08-02T22:54:44.103-04:00'!runTask    | message |    self isWaitingWithPacket	ifTrue: 	    [message := input.	    input := message link.	    input isNil		ifTrue: [self running]		ifFalse: [self packetPending]]	ifFalse: [message := nil].    ^function value: message value: handle! !!BeRiTaskState class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.103-04:00'!packetPending    ^super new packetPending! !!BeRiTaskState class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.103-04:00'!running    ^super new running! !!BeRiTaskState class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.104-04:00'!waiting    ^super new waiting! !!BeRiTaskState class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.104-04:00'!waitingWithPacket    ^super new waitingWithPacket! !!BeRiTaskState methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.104-04:00'!isPacketPending    ^packetPendingIV! !!BeRiTaskState methodsFor: 'testing' stamp: '2025-08-02T22:54:44.104-04:00'!isRunning    ^packetPendingIV not and: [taskWaiting not and: [taskHolding not]]! !!BeRiTaskState methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.104-04:00'!isTaskHolding    ^taskHolding! !!BeRiTaskState methodsFor: 'testing' stamp: '2025-08-02T22:54:44.104-04:00'!isTaskHoldingOrWaiting    ^taskHolding or: [packetPendingIV not and: [taskWaiting]]! !!BeRiTaskState methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.104-04:00'!isTaskWaiting    ^taskWaiting! !!BeRiTaskState methodsFor: 'testing' stamp: '2025-08-02T22:54:44.105-04:00'!isWaiting    ^packetPendingIV not and: [taskWaiting and: [taskHolding not]]! !!BeRiTaskState methodsFor: 'testing' stamp: '2025-08-02T22:54:44.105-04:00'!isWaitingWithPacket    ^packetPendingIV and: [taskWaiting and: [taskHolding not]]! !!BeRiTaskState methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.105-04:00'!packetPending    packetPendingIV := true.    taskWaiting := false.    taskHolding := false! !!BeRiTaskState methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.105-04:00'!running    packetPendingIV := taskWaiting := taskHolding := false! !!BeRiTaskState methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.105-04:00'!taskHolding: aBoolean    taskHolding := aBoolean! !!BeRiTaskState methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.105-04:00'!taskWaiting: aBoolean     taskWaiting := aBoolean! !!BeRiTaskState methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.105-04:00'!waiting    packetPendingIV := taskHolding := false.    taskWaiting := true! !!BeRiTaskState methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.105-04:00'!waitingWithPacket    taskHolding := false.    taskWaiting := packetPendingIV := true! !!BeRiWorkerTaskDataRecord class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.105-04:00'!create    ^super new create! !!BeRiWorkerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.106-04:00'!count    ^count! !!BeRiWorkerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.106-04:00'!count: aCount    count := aCount! !!BeRiWorkerTaskDataRecord methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.106-04:00'!create    destination := HandlerA.    count := 0! !!BeRiWorkerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.106-04:00'!destination    ^destination! !!BeRiWorkerTaskDataRecord methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.106-04:00'!destination: aHandler    destination := aHandler! !!BeRichardsBenchmark class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.107-04:00'!report: string times: count run: aBlock        "Report the time required to execute the given block."        | time |        time := 0.	count timesRepeat: [ time := time + aBlock value ].        Transcript show: string, ' ', (time // count) printString, ' milliseconds'; cr.! !!BeRichardsBenchmark class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.107-04:00'!standardBenchmark        "This the combined benchmark."        "BeRichardsBenchmark standardBenchmark"        self report: 'Richards simulations' times: 100 run: [ self start ]! !!BeRichardsBenchmark class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.109-04:00'!start    "BeRichardsBenchmark start"    ^self new start! !!BeRichardsBenchmark class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.11-04:00'!start: trace    "BeRichardsBenchmark start: true"    ^self new start: trace! !!BeRichardsBenchmark methodsFor: 'creation' stamp: '2025-08-02T22:54:44.11-04:00'!createDevice: identity priority: priority work: workX state: state     | dataX |    dataX := BeRiDeviceTaskDataRecord create.    self	createTask: identity	priority: priority	work: workX	state: state	function: 	    [:work :word | | data functionWork |	    data := word.	    functionWork := work.	    functionWork isNil		ifTrue:		    [(functionWork := data pending) isNil			ifTrue: [self wait]			ifFalse: 			    [data pending: nil.			    self queuePacket: functionWork]]		ifFalse: 		    [data pending: functionWork.		    tracing			ifTrue: 			    [self trace: functionWork datum].		    self holdSelf]]	data: dataX! !!BeRichardsBenchmark methodsFor: 'creation' stamp: '2025-08-02T22:54:44.112-04:00'!createHandler: identity priority: priority work: workX state: state     | dataX |    dataX := BeRiHandlerTaskDataRecord create.    self	createTask: identity	priority: priority	work: workX	state: state	function: 	    [:work :word | | data workPacket count devicePacket |	    data := word.	    work isNil		ifFalse: [WorkPacketKind == work kind 		    ifTrue: [data workInAdd: work]		    ifFalse: [data deviceInAdd: work]].	    (workPacket := data workIn) isNil		ifTrue: [self wait]		ifFalse: 		    [count := workPacket datum.		    count > 4			ifTrue: 			    [data workIn: workPacket link.			    self queuePacket: workPacket]			ifFalse:			    [(devicePacket := data deviceIn) isNil				ifTrue: [self wait]				ifFalse: 				    [data deviceIn: devicePacket link.				    devicePacket datum: (workPacket data at: count).				    workPacket datum: count + 1.				    self queuePacket: devicePacket]]]]	data: dataX! !!BeRichardsBenchmark methodsFor: 'creation' stamp: '2025-08-02T22:54:44.113-04:00'!createIdler: identity priority: priority work: workX state: state     | dataX |    dataX := BeRiIdleTaskDataRecord create.    self	createTask: identity	priority: priority	work: workX	state: state	function: 	    [:work :word | | data |	    data := word.	    data count: data count - 1.	    0 = data count		ifTrue: [self holdSelf]		ifFalse:		    [0 = (data control bitAnd: 1)			ifTrue: 			    [data control: data control // 2.			    self release: DeviceA]			ifFalse: 			    [data control: (data control // 2 bitXor: 53256).			    self release: DeviceB]]]	data: dataX! !!BeRichardsBenchmark methodsFor: 'creation' stamp: '2025-08-02T22:54:44.113-04:00'!createPacket: link identity: identity kind: kind     ^BeRiPacket	create: link	identity: identity	kind: kind! !!BeRichardsBenchmark methodsFor: 'creation' stamp: '2025-08-02T22:54:44.113-04:00'!createTask: identity priority: priority work: workX state: state function: aBlock data: data     | t |    t := BeRiTaskControlBlock		link: taskList		create: identity		priority: priority		initialWorkQueue: workX		initialState: state		function: aBlock		privateData: data.    taskList := t.    taskTable at: identity put: t! !!BeRichardsBenchmark methodsFor: 'creation' stamp: '2025-08-02T22:54:44.114-04:00'!createWorker: identity priority: priority work: workX state: state     | dataX |    dataX := BeRiWorkerTaskDataRecord create.    self	createTask: identity	priority: priority	work: workX	state: state	function: 	    [:work :word | | data |	    data := word.	    work isNil		ifTrue: [self wait]		ifFalse: 		    [data destination: (HandlerA = data destination			    ifTrue: [HandlerB]			    ifFalse: [HandlerA]).		    work identity: data destination.		    work datum: 1.		    1 to: 4 do: 			[:i | 			data count: data count + 1.			data count > 26 ifTrue: [data count: 1].			work data at: i put: $A asInteger + data count - 1].		    self queuePacket: work]]	data: dataX! !!BeRichardsBenchmark methodsFor: 'private' stamp: '2025-08-02T22:54:44.115-04:00'!findTask: identity     | t |    t := taskTable at: identity.    t isNil ifTrue: [self error: 'findTask failed'].    ^t! !!BeRichardsBenchmark methodsFor: 'private' stamp: '2025-08-02T22:54:44.115-04:00'!holdSelf    holdCount := holdCount + 1.    currentTask taskHolding: true.    ^currentTask link! !!BeRichardsBenchmark methodsFor: 'private' stamp: '2025-08-02T22:54:44.115-04:00'!initScheduler    queuePacketCount := holdCount := 0.    taskTable := Array new: 6.    taskList := nil! !!BeRichardsBenchmark methodsFor: 'private' stamp: '2025-08-02T22:54:44.115-04:00'!initTrace: trace    tracing := trace.    layout := 0! !!BeRichardsBenchmark methodsFor: 'private' stamp: '2025-08-02T22:54:44.115-04:00'!queuePacket: packet     | t |    t := self findTask: packet identity.    t isNil ifTrue: [^nil].    queuePacketCount := queuePacketCount + 1.    packet link: nil.    packet identity: currentTaskIdentity.    ^t addInput: packet checkPriority: currentTask! !!BeRichardsBenchmark methodsFor: 'private' stamp: '2025-08-02T22:54:44.115-04:00'!release: identity     | t |    t := self findTask: identity.    t isNil ifTrue: [^nil].    t taskHolding: false.    t priority > currentTask priority	ifTrue: [^t]	ifFalse: [^currentTask]! !!BeRichardsBenchmark methodsFor: 'scheduling' stamp: '2025-08-02T22:54:44.116-04:00'!schedule    currentTask := taskList.     [currentTask isNil]	whileFalse: 	    [currentTask isTaskHoldingOrWaiting		ifTrue: [currentTask := currentTask link]		ifFalse: 		    [currentTaskIdentity := currentTask identity.		    tracing ifTrue: [self trace: currentTaskIdentity].		    currentTask := currentTask runTask]]! !!BeRichardsBenchmark methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.116-04:00'!start    ^self start: false! !!BeRichardsBenchmark methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.118-04:00'!start: trace    | workQ mark1 mark2 mark3 mark4 |    self initTrace: trace; initScheduler.    mark1 := Time microsecondClockValue.    tracing ifTrue: [Transcript show: 'Bench mark starting'; cr].    self	createIdler: Idler	priority: 0	work: nil	state: BeRiTaskState running.    workQ := self		createPacket: nil		identity: Worker		kind: WorkPacketKind.    workQ := self		createPacket: workQ		identity: Worker		kind: WorkPacketKind.    self	createWorker: Worker	priority: 1000	work: workQ	state: BeRiTaskState waitingWithPacket.    workQ := self		createPacket: nil		identity: DeviceA		kind: DevicePacketKind.    workQ := self		createPacket: workQ		identity: DeviceA		kind: DevicePacketKind.    workQ := self		createPacket: workQ		identity: DeviceA		kind: DevicePacketKind.    self	createHandler: HandlerA	priority: 2000	work: workQ	state: BeRiTaskState waitingWithPacket.    workQ := self		createPacket: nil		identity: DeviceB		kind: DevicePacketKind.    workQ := self		createPacket: workQ		identity: DeviceB		kind: DevicePacketKind.    workQ := self		createPacket: workQ		identity: DeviceB		kind: DevicePacketKind.    self	createHandler: HandlerB	priority: 3000	work: workQ	state: BeRiTaskState waitingWithPacket.    self	createDevice: DeviceA	priority: 4000	work: nil	state: BeRiTaskState waiting.    self	createDevice: DeviceB	priority: 5000	work: nil	state: BeRiTaskState waiting.    tracing ifTrue: [Transcript show: 'Starting'; cr].    mark2 := Time microsecondClockValue.    self schedule.    mark3 := Time microsecondClockValue.    tracing	ifTrue: 	    [Transcript show: 'Finished'; cr.	    Transcript show: 'QueuePacket count = ' ;		show: queuePacketCount printString;		show: ' HoldCount = ';		show: holdCount printString;		cr.	    Transcript cr; show: 'End of run'; cr].    queuePacketCount = 23246 & (holdCount = 9297) ifFalse: [self error: 'wrong result'].    mark4 := Time millisecondClockValue.    tracing	ifTrue:	    [Transcript show: '***Scheduler time = ';	        show: (mark3 - mark2) printString;	        show: ' Total time = ';	        show: (mark4 - mark1) printString;	        cr].  ^mark3 - mark2! !!BeRichardsBenchmark methodsFor: 'private' stamp: '2025-08-02T22:54:44.119-04:00'!trace: id     layout := layout - 1.    0 >= layout	ifTrue: 	    [Transcript cr.	    layout := 50].    Transcript show: id printString! !!BeRichardsBenchmark methodsFor: 'private' stamp: '2025-08-02T22:54:44.119-04:00'!wait     currentTask taskWaiting: true.    ^currentTask! !!BeDeltaBlue class methodsFor: 'benchmarks' stamp: '2025-08-02T22:54:44.12-04:00'!chainTest: n	"Do chain-of-equality-constraints performance tests."	| vars editConstraint plan planner |	planner := BeDeltaBlue new.	vars := (1 to: n+1) collect: [ :i | BeDBVariable new].	"thread a chain of equality constraints through the variables"	1 to: n do:		[ :i || v1 v2 |		 v1 := vars at: i.		 v2 := vars at: i + 1.		 BeDBEqualityConstraint var: v1 var: v2 strength: #required].	BeDBStayConstraint var: vars last strength: #strongDefault.	editConstraint := BeDBEditConstraint var: (vars first) strength: #preferred.	plan := planner extractPlanFromConstraints: (Array with: editConstraint).	1 to: 100 do: [ :v | 		vars first value: v.		plan execute.		vars last value ~= v ifTrue: [self error: 'Chain test failed!!']].	editConstraint destroyConstraint! !!BeDeltaBlue class methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.12-04:00'!current	^currentPlanner! !!BeDeltaBlue class methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.121-04:00'!innerIterations	^ 715! !!BeDeltaBlue class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.121-04:00'!new	^ currentPlanner := super new! !!BeDeltaBlue class methodsFor: 'benchmarks' stamp: '2025-08-02T22:54:44.122-04:00'!projectionTest: n	"This test constructs a two sets of variables related to each other by	 a simple linear transformation (scale and offset)."	| scale offset src dst planner dests |	planner := BeDeltaBlue new.	dests := OrderedCollection new.	scale := BeDBVariable value: 10.	offset := BeDBVariable value: 1000.	1 to: n do:		[ :i |		src := BeDBVariable value: i.		dst := BeDBVariable value: i.		dests add: dst.		BeDBStayConstraint var: src strength: #default.		BeDBScaleConstraint var: src var: scale var: offset var: dst strength: #required].	planner changeVar: src newValue: 17.	dst value ~= 1170 ifTrue: [self error: 'Projection test 1 failed!!'].	planner changeVar: dst newValue: 1050.	src value ~= 5 ifTrue: [self error: 'Projection test 2 failed!!'].	planner changeVar: scale newValue: 5.	1 to: n - 1 do: [ :i |		(dests at: i) value ~= (i*5 + 1000)			ifTrue: [self error: 'Projection test 3 failed!!']].	planner changeVar: offset newValue: 2000.	1 to: n - 1 do: [ :i |		(dests at: i) value ~= (i*5 + 2000)			ifTrue: [self error: 'Projection test 4 failed!!']].! !!BeDeltaBlue class methodsFor: 'benchmarks' stamp: '2025-08-02T22:54:44.123-04:00'!report: string times: count run: aBlock	"Report the time required to execute the given block."	| time |	time := Time microsecondsToRun: [count timesRepeat: aBlock].	Transcript show: string, ' ', (time // count) printString, ' microseconds'; cr.! !!BeDeltaBlue class methodsFor: 'benchmarks' stamp: '2025-08-02T22:54:44.123-04:00'!standardBenchmark	"This the combined benchmark."	"BeDBPlanner standardBenchmark"	self report: 'Chain and projection tests' times: 100 run: [		self chainTest: 100. 		self projectionTest: 100	]! !!BeDeltaBlue class methodsFor: 'benchmarks' stamp: '2025-08-02T22:54:44.123-04:00'!start	^ self standardBenchmark! !!BeDeltaBlue methodsFor: 'private' stamp: '2025-08-02T22:54:44.125-04:00'!addConstraintsConsuming: v to: aCollection	| determiningC |	determiningC := v determinedBy.	v constraints do:		[: c |		 ((c == determiningC) or: [c isSatisfied not]) ifFalse:			[aCollection add: c]].! !!BeDeltaBlue methodsFor: 'private' stamp: '2025-08-02T22:54:44.126-04:00'!addPropagate: c mark: mark	"Recompute the walkabout strengths and stay flags of all variables	 downstream of the given constraint and recompute the actual values	 of all variables whose stay flag is true. If a cycle is detected,	 remove the given constraint and answer false. Otherwise, answer true.	 Details: Cycles are detected when a marked variable is encountered	 downstream of the given constraint. The sender is assumed to have	 marked the inputs of the given constraint with the given mark. Thus,	 encountering a marked node downstream of the output constraint means	 that there is a path from the constraint's output to one of its	 inputs."	| todo d |	todo := OrderedCollection with: c.	[todo isEmpty] whileFalse:		[d := todo removeFirst.		 (d output mark = mark) ifTrue:			[self incrementalRemove: c.			 ^false].		 d recalculate.		 self addConstraintsConsuming: d output to: todo].	^true! !!BeDeltaBlue methodsFor: 'private' stamp: '2025-08-02T22:54:44.127-04:00'!changeVar: aVariable newValue: newValue	| editConstraint plan |	editConstraint := BeDBEditConstraint var: aVariable strength: #preferred.	plan := self extractPlanFromConstraints: (Array with: editConstraint).	10 timesRepeat: [		aVariable value: newValue.		plan execute].	editConstraint destroyConstraint.! !!BeDeltaBlue methodsFor: 'private' stamp: '2025-08-02T22:54:44.127-04:00'!constraintsConsuming: v do: aBlock	| determiningC |	determiningC := v determinedBy.	v constraints do:		[: c |		 ((c == determiningC) or: [c isSatisfied not]) ifFalse:			[aBlock value: c]].! !!BeDeltaBlue methodsFor: 'planning/value propagation' stamp: '2025-08-02T22:54:44.128-04:00'!extractPlanFromConstraints: constraints	"Extract a plan for resatisfaction starting from the outputs of the	 given constraints, usually a set of input constraints."	| sources |	sources := OrderedCollection new.	constraints do:		[: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]].	^self makePlan: sources! !!BeDeltaBlue methodsFor: 'planning/value propagation' stamp: '2025-08-02T22:54:44.128-04:00'!extractPlanFromVariables: variables	"Extract a plan from the dataflow graph having the given variables. It	 is assumed that the given set of variables is complete, or at least	 that it contains all the input variables."	| sources |	sources := OrderedCollection new.	variables do:		[: v |		 (v constraints) do:			[: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]]].	^self makePlan: sources! !!BeDeltaBlue methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.128-04:00'!incrementalAdd: c	"Attempt to satisfy the given constraint and, if successful,	 incrementally update the dataflow graph.	 Details: If satifying the constraint is successful, it may override a	 weaker constraint on its output. The algorithm attempts to resatisfy	 that constraint using some other method. This process is repeated	 until either a) it reaches a variable that was not previously	 determined by any constraint or b) it reaches a constraint that	 is too weak to be satisfied using any of its methods. The variables	 of constraints that have been processed are marked with a unique mark	 value so that we know where we've been. This allows the algorithm to	 avoid getting into an infinite loop even if the constraint graph has	 an inadvertent cycle."	| mark overridden |	mark := self newMark.	overridden := c satisfy: mark.	[overridden == nil] whileFalse:		[overridden := overridden satisfy: mark].! !!BeDeltaBlue methodsFor: 'add/remove' stamp: '2025-08-02T22:54:44.129-04:00'!incrementalRemove: c	"Entry point for retracting a constraint. Remove the given constraint,	 which should be satisfied, and incrementally update the dataflow	 graph.	 Details: Retracting the given constraint may allow some currently	 unsatisfiable downstream constraint be satisfied. We thus collect a	 list of unsatisfied downstream constraints and attempt to satisfy	 each one in turn. This list is sorted by constraint strength,	 strongest first, as a heuristic for avoiding unnecessarily adding	 and then overriding weak constraints."	| out unsatisfied |	out := c output.	c markUnsatisfied.	c removeFromGraph.	unsatisfied := self removePropagateFrom: out.	unsatisfied do: [: u | self incrementalAdd: u].! !!BeDeltaBlue methodsFor: 'initialize' stamp: '2025-08-02T22:54:44.129-04:00'!initialize	"BeDBPlanner initialize"	currentMark := 1.! !!BeDeltaBlue methodsFor: 'running' stamp: '2025-08-02T22:54:44.13-04:00'!innerBenchmarkLoop: iterations	iterations timesRepeat: [		self class chainTest: 100. 		self class projectionTest: 100	].	^ true! !!BeDeltaBlue methodsFor: 'planning/value propagation' stamp: '2025-08-02T22:54:44.13-04:00'!makePlan: sources	"Extract a plan for resatisfaction starting from the given satisfied	 source constraints, usually a set of input constraints. This method	 assumes that stay optimization is desired; the plan will contain only	 constraints whose output variables are not stay. Constraints that do	 no computation, such as stay and edit constraints, are not included	 in the plan.	 Details: The outputs of a constraint are marked when it is added to	 the plan under construction. A constraint may be appended to the plan	 when all its input variables are known. A variable is known if either	 a) the variable is marked (indicating that has been computed by a	 constraint appearing earlier in the plan), b) the variable is 'stay'	 (i.e. it is a constant at plan execution time), or c) the variable	 is not determined by any constraint. The last provision is for past	 states of history variables, which are not stay but which are also	 not computed by any constraint."	| mark plan todo c |	mark := self newMark.	plan := BeDBPlan new.	todo := sources.	[todo isEmpty] whileFalse:		[c := todo removeFirst.		 ((c output mark ~= mark) and:		"not in plan already and..."		  [c inputsKnown: mark]) ifTrue:	"eligible for inclusion"			[plan addLast: c.			 c output mark: mark.			 self addConstraintsConsuming: c output to: todo]].	^plan! !!BeDeltaBlue methodsFor: 'private' stamp: '2025-08-02T22:54:44.13-04:00'!newMark	"Select a previously unused mark value.	 Details: We just keep incrementing. If necessary, the counter will	 turn into a LargePositiveInteger. In that case, it will be a bit	 slower to compute the next mark but the algorithms will all behave	 correctly. We reserve the value '0' to mean 'unmarked'. Thus, this	 generator starts at '1' and will never produce '0' as a mark value."	^currentMark := currentMark + 1! !!BeDeltaBlue methodsFor: 'planning/value propagation' stamp: '2025-08-02T22:54:44.131-04:00'!propagateFrom: v	"The given variable has changed. Propagate new values downstream."	| todo c |	todo := OrderedCollection new.	self addConstraintsConsuming: v to: todo.	[todo isEmpty] whileFalse:		[c := todo removeFirst.		 c execute.		 self addConstraintsConsuming: c output to: todo].! !!BeDeltaBlue methodsFor: 'private' stamp: '2025-08-02T22:54:44.135-04:00'!removePropagateFrom: out	"Update the walkabout strengths and stay flags of all variables	 downstream of the given constraint. Answer a collection of unsatisfied	 constraints sorted in order of decreasing strength."	| unsatisfied todo v nextC |	unsatisfied := SortedCollection sortBlock:		[: c1 : c2 | c1 strength stronger: c2 strength].	out determinedBy: nil.	out walkStrength: BeDBStrength absoluteWeakest.	out stay: true.	todo := OrderedCollection with: out.	[todo isEmpty] whileFalse:		[v := todo removeFirst.		 v constraints do:		 	[: c | (c isSatisfied) ifFalse: [unsatisfied add: c]].		 self constraintsConsuming: v do:			[: c |			 c recalculate.			 todo add: c output]].	^unsatisfied! !!BeMandelbrot class methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.135-04:00'!innerIterations	^ 466! !!BeMandelbrot methodsFor: 'controlling' stamp: '2025-08-02T22:54:44.135-04:00'!innerBenchmarkLoop: iterations	^ self		  verify: (self mandelbrot: iterations)		  inner: iterations! !!BeMandelbrot methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.137-04:00'!mandelbrot: size	| sum byteAcc bitNum y |	sum := 0.	byteAcc := 0.	bitNum := 0.	y := 0.	[ y < size ] whileTrue: [		| ci x |		ci := 2.0 * y / size - 1.0.		x := 0.		[ x < size ] whileTrue: [			| zrzr zi zizi cr escape z notDone |			zrzr := 0.0.			zizi := zi := 0.0.			cr := 2.0 * x / size - 1.5.			z := 0.			notDone := true.			escape := 0.			[ notDone and: [ z < 50 ] ] whileTrue: [				| zr |				zr := zrzr - zizi + cr.				zi := 2.0 * zr * zi + ci.				"preserve recalculation"				zrzr := zr * zr.				zizi := zi * zi.				zrzr + zizi > 4.0 ifTrue: [					notDone := false.					escape := 1 ].				z := z + 1 ].			byteAcc := byteAcc << 1 + escape.			bitNum := bitNum + 1.			" Code is very similar for these cases, but using separate blocks                ensures we skip the shifting when it's unnecessary,                which is most cases. "			bitNum = 8				ifTrue: [					sum := sum bitXor: byteAcc.					byteAcc := 0.					bitNum := 0 ]				ifFalse: [					x = (size - 1) ifTrue: [						byteAcc := byteAcc << (8 - bitNum).						sum := sum bitXor: byteAcc.						byteAcc := 0.						bitNum := 0 ] ].			x := x + 1 ].		y := y + 1 ].	^ sum! !!BeMandelbrot methodsFor: 'verification' stamp: '2025-08-02T22:54:44.138-04:00'!verify: result inner: iterations	iterations = 325 ifTrue: [ ^ result = 248 ].	iterations = 450 ifTrue: [ ^ result = 13 ].	iterations = 466 ifTrue: [ ^ result = 253 ].	iterations = 475 ifTrue: [ ^ result = 191 ].	iterations = 500 ifTrue: [ ^ result = 191 ].	iterations = 750 ifTrue: [ ^ result = 50 ].	iterations = 1000 ifTrue: [ ^ result = 101 ].	iterations = 2500 ifTrue: [ ^ result = 231 ].	iterations = 1 ifTrue: [ ^ result = 128 ].	ScriptConsole 		<< 'No verification result for ';		<< iterations asString;		<< ' found';		cr.	ScriptConsole		<< 'Result is: ';		<< result asString;		cr.	^ false! !!BeMatrixInversion class methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.138-04:00'!innerIterations	^ 250! !!BeMatrixInversion methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.138-04:00'!initialize	super initialize.	size := 10.	sourceMatrix := random makeInvertable: size! !!BeMatrixInversion methodsFor: 'running' stamp: '2025-08-02T22:54:44.139-04:00'!innerBenchmarkLoop: iterations	| result |	result := true.	1 to: iterations do: [ :i | result := result and: self multiplyInverse ].	^ result! !!BeMatrixInversion methodsFor: 'running' stamp: '2025-08-02T22:54:44.139-04:00'!multiplyInverse 	" calculate the inverse of sourceMatrix - non-destructively "	" then multiply that by sourceMatrix and return true if the result is close to an identity matrix, else false "		^ false! !!BeNBody class methodsFor: 'instance creation' stamp: '2025-08-02T22:54:44.139-04:00'!new	BeBody initialize.   ^ super new! !!BeNBody methodsFor: 'running' stamp: '2025-08-02T22:54:44.139-04:00'!innerBenchmarkLoop: iterations	| system |	system := BeNBodySystem new.	1 to: iterations do: [ :i | system advance: 0.01 ].	^ self verify: system energy for: iterations! !!BeNBody methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.14-04:00'!verify: result for: iterations	iterations = 250000 ifTrue: [ ^ result = -0.1690859889909308  ].	iterations =      1 ifTrue: [ ^ result = -0.16907495402506745 ].	ScriptConsole << 'No verification result for ' << iterations asString << ' found'; cr.	ScriptConsole << 'Result is: ' << result asString; cr.	^ false! !!BeQueens class methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.14-04:00'!innerIterations	^ 30000! !!BeQueens methodsFor: 'running' stamp: '2025-08-02T22:54:44.14-04:00'!innerBenchmarkLoop: iterations	| result |	result := true.	1 to: iterations do: [ :i | result := result and: self queens ].	^ result! !!BeQueens methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.141-04:00'!placeQueen: c    1 to: 8 do: [ :r |       (self row: r column: c)        ifTrue: [          queenRows at: r put: c.          self row: r column: c put: false.          (c = 8) ifTrue: [ ^ true ].          (self placeQueen: c + 1) ifTrue: [ ^ true ].          self row: r column: c put: true ] ].    ^ false! !!BeQueens methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.141-04:00'!queens	freeRows := Array new: 8 withAll: true.	freeMaxs := Array new: 16 withAll: true.	freeMins := Array new: 16 withAll: true.	queenRows := Array new: 8 withAll: -1.	^ self placeQueen: 1! !!BeQueens methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.142-04:00'!row: r column: c    ^ (freeRows at: r) and: [(freeMaxs at: c + r) and: [(freeMins at: c - r + 8)]]! !!BeQueens methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.142-04:00'!row: r column: c put: v    freeRows at: r         put: v.    freeMaxs at: c + r     put: v.    freeMins at: c - r + 8 put: v.! !!BeSieve class methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.142-04:00'!innerIterations	^ 12500000! !!BeSieve methodsFor: 'running' stamp: '2025-08-02T22:54:44.142-04:00'!innerBenchmarkLoop: iterations	^ self		  verify: (self sieve: (Array new: iterations  withAll: true))		  for: iterations! !!BeSieve methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.142-04:00'!iterations	^ 10000! !!BeSieve methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.143-04:00'!sieve: flags	| size primeCount |	size := flags size.	primeCount := 0.	2 to: size do: [ :i |		(flags at: i - 1) ifTrue: [			| k |			primeCount := primeCount + 1.			k := i + i.			[ k <= size ] whileTrue: [				flags at: k - 1 put: false.				k := k + i ]. ] ].	^ primeCount! !!BeSieve methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.144-04:00'!verify: result for: iterations	iterations = 12500000 ifTrue: [ ^ result = 818703 ].	iterations = 10000000 ifTrue: [ ^ result = 664579 ].	iterations =  1000000 ifTrue: [ ^ result = 78498 ].	iterations =   250000 ifTrue: [ ^ result = 22044 ].	iterations =    10000 ifTrue: [ ^ result = 1229 ].	iterations =     5000 ifTrue: [ ^ result = 669 ].	iterations =        1 ifTrue: [ ^ result = 0 ].	ScriptConsole << 'No verification result for ' << iterations asString << ' found'; cr.	ScriptConsole << 'Result is: ' << result asString; cr.	^ false! !!Benchmark class methodsFor: 'as yet unclassified' stamp: '2025-08-02T22:54:44.144-04:00'!allBenchmarks	^ self instanceSide subclasses! !!Benchmark class methodsFor: 'reflective operations' stamp: '2025-08-02T22:54:44.144-04:00'!benchmark: aString	^ self new initialize: aString! !!Benchmark class methodsFor: 'reflective operations' stamp: '2025-08-02T22:54:44.144-04:00'!doesNotUnderstand: aMessage	(Smalltalk classNamed: aMessage selector) ifNil: [		(Smalltalk classNamed: #Be, aMessage selector) ifNil: [			^ super doesNotUnderstand: aMessage ]].	^ self run: aMessage selector! !!Benchmark class methodsFor: 'class initialization' stamp: '2025-08-02T22:54:44.144-04:00'!initialize	ScriptConsole := Transcript! !!Benchmark class methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.145-04:00'!innerIterations	^ 250000! !!Benchmark class methodsFor: 'benchmarking' stamp: '2025-08-02T22:54:44.145-04:00'!mainIterations	^ 10! !!Benchmark class methodsFor: 'running' stamp: '2025-08-02T22:54:44.145-04:00'!run	self == Benchmark ifTrue: [		^ self allBenchmarks do: [ : benchmark | self run: benchmark name ] ].	^ self run: name! !!Benchmark class methodsFor: 'reflective operations' stamp: '2025-08-02T22:54:44.145-04:00'!run: aString	^ (self benchmark: aString asSymbol) runBenchmark! !!Benchmark methodsFor: 'running' stamp: '2025-08-02T22:54:44.146-04:00'!doRuns: bench    1 to: mainIterations do: [:i |      self measure: bench    ]! !!Benchmark methodsFor: 'calculating' stamp: '2025-08-02T22:54:44.146-04:00'!firstQuartile	^ times quartiles first! !!Benchmark methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.146-04:00'!initialize	super initialize.	logging := false.	random := BeRandom new! !!Benchmark methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.146-04:00'!initialize: aName	name := aName.	benchmarkSuite := self loadBenchmarkSuite: aName.	total := 0.	totalsq := 0.	mainIterations := benchmarkSuite mainIterations.	innerIterations := benchmarkSuite innerIterations.	times := OrderedCollection new! !!Benchmark methodsFor: 'running' stamp: '2025-08-02T22:54:44.147-04:00'!innerBenchmarkLoop: unreferenced	^ self subclassResponsibility! !!Benchmark methodsFor: 'initialization' stamp: '2025-08-02T22:54:44.147-04:00'!loadBenchmarkSuite: className	| cls |	cls := Smalltalk classNamed: className.	cls ifNil: [		cls := Smalltalk classNamed: (#Be, className).		cls ifNil: [			self error: 'Failed loading benchmark: ', className ] ].	^ cls! !!Benchmark methodsFor: 'calculating' stamp: '2025-08-02T22:54:44.147-04:00'!max	^ times max! !!Benchmark methodsFor: 'calculating' stamp: '2025-08-02T22:54:44.148-04:00'!mean	^ total // mainIterations! !!Benchmark methodsFor: 'running' stamp: '2025-08-02T22:54:44.148-04:00'!measure: bench	| startTime endTime runTime |	startTime := Time primUTCMicrosecondsClock.	(bench innerBenchmarkLoop: innerIterations) ifFalse: [		self error: 'Benchmark failed with incorrect result' ].	endTime := Time primUTCMicrosecondsClock.	runTime := endTime - startTime.	logging ifTrue: [self printResult: runTime].	times add: runTime.	totalsq := totalsq + (runTime * runTime).	total := total + runTime! !!Benchmark methodsFor: 'calculating' stamp: '2025-08-02T22:54:44.148-04:00'!median	^ times quartiles second! !!Benchmark methodsFor: 'calculating' stamp: '2025-08-02T22:54:44.148-04:00'!min	^ times min! !!Benchmark methodsFor: 'reporting' stamp: '2025-08-02T22:54:44.148-04:00'!printResult: runTime	ScriptConsole		<<< name;		<<< ': iterations=1 runtime: ';		<<< runTime;		<<< 'us';		cr! !!Benchmark methodsFor: 'reporting' stamp: '2025-08-02T22:54:44.149-04:00'!printTotal	ScriptConsole		<<< 'Total Runtime: ';		<<< total;		<<< 'us';		cr! !!Benchmark methodsFor: 'reporting' stamp: '2025-08-02T22:54:44.149-04:00'!reportBenchmark	ScriptConsole		<< name;		<< ': n=';		<< mainIterations;		<< ' mean: ';		<< self mean;		<< 'us stdDev: ';		<< self stdDev asInteger;		<< 'us (';		<< (self stdDev / self mean * 100 printShowingDecimalPlaces: 1);		<< '%) min: ';		<< self min;		<< 'us 1stQ: ';		<< self firstQuartile;		<< 'us ';		<< ' median: ';		<< self median;		<< 'us ';		<< ' 3rdQ: ';		<< self thirdQuartile;		<< 'us ';		<< ' max: ';		<< self max;		<< 'us ';		cr! !!Benchmark methodsFor: 'running' stamp: '2025-08-02T22:54:44.15-04:00'!runBenchmark	ScriptConsole		<< 'Starting ' << name << ' benchmark ... ';cr;		flush.	WorldMorph doOneCycle.	Smalltalk garbageCollect.	self doRuns: benchmarkSuite new.	self reportBenchmark.	ScriptConsole cr! !!Benchmark methodsFor: 'calculating' stamp: '2025-08-02T22:54:44.15-04:00'!stdDev	^ (totalsq / mainIterations - (total / mainIterations) squared ) sqrt! !!Benchmark methodsFor: 'calculating' stamp: '2025-08-02T22:54:44.15-04:00'!thirdQuartile	^ times quartiles third! !!Benchmark methodsFor: 'accessing' stamp: '2025-08-02T22:54:44.15-04:00'!times	^ times asArray! !!Object methodsFor: '*ZagBench' stamp: '2025-08-02T22:54:44.15-04:00'!printOrPutOn: aStream	self printOn: aStream! !"ZagBench"!!BeRandom methodsFor: 'random value creation' stamp: '2025-08-03T00:09:49.27-04:00' prior: 86315!randomWithRows: rows columns: cols	^ (1 to: rows) collect: [ :i |		  (1 to: cols) collect: [ :j | self next ] ]	"| myRandomMatrixGenerator aSquareMatrix aNonSquareMatrix |""Step 1: Create an instance of the BeRandom class""myRandomMatrixGenerator := BeRandom new.""Step 2: Create a 3x3 square matrix""aSquareMatrix := myRandomMatrixGenerator randomSquare: 3."! !!UndefinedObject methodsFor: 'nil' stamp: '2025-08-03T00:16:36.586-04:00'!makeInvertable: anInteger 	self shouldBeImplemented.! !----SNAPSHOT----2025-08-03T01:55:42.228-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 526!----SNAPSHOT----2025-08-03T01:55:42.243-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 85889!----QUIT----2025-08-03T01:55:59.528-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 86009!----QUIT----2025-08-03T01:55:59.545-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 86131!----QUIT----2025-08-06T14:41:48.775-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 86249!----QUIT----2025-08-06T14:41:48.802-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 86367!!BaselineOfAIMooseLinearAlgebra methodsFor: 'baselines' stamp: '2025-08-06T15:19:12.753-04:00'!baseline: spec  <baseline>	spec		for: #(common)		do: [ 			spec 				package: 'AI-MooseLinearAlgebra';				package: 'AI-MooseLinearAlgebra-Tests' with: [ spec requires: #('AI-MooseLinearAlgebra') ].			spec 				group: 'Core' with: #('AI-MooseLinearAlgebra');				group: 'Tests' with: #('AI-MooseLinearAlgebra' 'AI-MooseLinearAlgebra-Tests');				group: 'default' with: #('Core' 'Tests') ]! !"BaselineOfAIMooseLinearAlgebra"!!AIMapping commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AINameMapping commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AINumberMapping commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AISmartMapping commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIVector commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIArrayVector commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIBooleanVector commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIFloatVector commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMatrixPath commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AISparseVector commentStamp: '' prior: 0!SparseVector has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	contents	<(ArrayList of: (Association | Attribute | CodeComponentProperty | DeferredBinding | IndexedVariable | KeyedElement | LabelAndValue | NamedVariable | SetElement | SourceMapEntry | VariableBinding)) | (OrderedCollection of: (Association | Attribute | CodeComponentProperty | DeferredBinding | IndexedVariable | KeyedElement | LabelAndValue | NamedVariable | SetElement | SourceMapEntry | VariableBinding))>	description of contents	size	<ArithmeticValue | CPointer | Matrix | Rectangle | String | Vector>	description of size!!AIVectorCoercion commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIVectorDecorator commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMappedVector commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIAccumulator commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIArrayMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIColumnMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AISparseColumnMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMatrixCoercion commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMatrixDecorator commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMappedMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMatrixView commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIUnboundedMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIRowMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AISparseRowMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AISymetricMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIDiagonalMatrix commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIUnlimited commentStamp: '' prior: 0!An **unlimited** is a `Magnitude` which could be positive or negative.When positive, it's always greater than any other magnitude.When negative, it's always smaller than any other magnitude.## ExamplesMLUnlimited positive < 0.  "true"MLUnlimited positive > 0. "true"MLUnlimited positive > 1. "true"MLUnlimited positive > 2. "true"MLUnlimited negative > 0.  "false"MLUnlimited negative < 0.  "true"MLUnlimited negative < 1.  "true"MLUnlimited negative < 2.  "true"!!SequenceableCollection class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.243-04:00'!withSize: size	^ self new: size! !!SequenceableCollection methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.246-04:00'!asVector	^ AIArrayVector withAll: self.! !!SequenceableCollection methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.25-04:00'!hasSize: size	^ self size = size.! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.258-04:00'!checkForOldSyntax: t1 with: t2 on: t3	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point 	to an incorrect position in the file. The file may have been modified after 	this method was updated."		(t3 atEnd not and: [t3 peekFor: $.])		ifTrue:			[(t3 atEnd not				and:					[t3 peek digitValue						between: 0						and: t1 - 1])				ifTrue:					[self						error:							#errRadixDecimal << #dialogs >>									'Non-radix 10 numbers may not contain decimal points']				ifFalse: [t3 skip: -1]].	(t3 atEnd not and: [t3 peek asLowercase = $e])		ifTrue:			[self				error:					#errRadixExponent << #dialogs >>							'Non-radix 10 numbers may not have an exponent'].	^t2! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.259-04:00'!chooseFloatRepresentationFor: t1	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point 	to an incorrect position in the file. The file may have been modified after 	this method was updated."		^ Float! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.267-04:00'!coerce: t1 precision: t2 exponent: t3 exponentChar: t4	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point 	to an incorrect position in the file. The file may have been modified after 	this method was updated."	t3 ifNil: [ ^ self zero coerce: t1 ].	^ (self zero coerce: t1) * (10 raisedTo: t3)! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.27-04:00'!coerce: t1 to: t2 precision: t3 exponent: t4 exponentChar: t5	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point 	to an incorrect position in the file. The file may have been modified after 	this method was updated."		^t2 coerce: t1 precision: t3 exponent: t4 exponentChar: t5! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.273-04:00'!readIntegerFrom: t1 radix: t2	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point 	to an incorrect position in the file. The file may have been modified after 	this method was updated."		| t3 t4 |	t4 := 0.	[t1 atEnd]		whileFalse:			[((t3 := t1 next digitValue) < 0 or: [t3 >= t2])				ifTrue:					[t1 skip: -1.					^t4].			t4 := t4 * t2 + t3].	^t4! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.28-04:00'!readSmalltalkAndCFloat: integerPart from: aStream	"Answer an instance of me as described on the stream, aStream."	| value coercionClass possibleCoercionClass precision digit num den exp neg endOfNumber eChar |	precision := 0.	num := 0.	den := 1.	coercionClass := Integer.	(aStream peekFor: $.)		ifTrue: [ "<integer>.<fraction>"			(aStream atEnd not and: [ aStream peek isDigit ])				ifTrue: [ | atEnd |					coercionClass := Float.					[ (atEnd := aStream atEnd)						or: [ (digit := aStream next) isDigit not ] ]						whileFalse: [ num := num * 10 + digit digitValue.							precision := precision + 1 ].					den := 10 ** precision.					atEnd						ifFalse: [ aStream skip: -1 ] ]				ifFalse:					[ "oops - just <integer>." "un-gobble the period" aStream skip: -1 ] ].	eChar := aStream peek.	eChar		ifNil: [ possibleCoercionClass := nil ]		ifNotNil:			[ "SystemUtils isVW20LanguageCompatible ifTrue: [eChar := eChar asLowercase]."			possibleCoercionClass := self chooseFloatRepresentationFor: eChar.			possibleCoercionClass isNil				ifFalse: [ aStream next ] ].	exp := nil.	possibleCoercionClass == nil		ifFalse: [ coercionClass := possibleCoercionClass.			endOfNumber := aStream position.			(aStream peekFor: $+)				ifTrue: [ aStream next ].			neg := aStream peekFor: $-.			((digit := aStream peek) notNil and: [ digit isDigit ])				ifTrue: [ exp := self readIntegerFrom: aStream radix: 10.					neg						ifTrue: [ exp := exp negated ] ]				ifFalse: [ aStream position: endOfNumber ] ].	value := integerPart + (num / den).	"The exponent will be added in the next step."	^ self		coerce: value		to: coercionClass		precision: precision		exponent: exp		exponentChar: eChar! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.282-04:00'!readSmalltalkAndCSyntaxFrom: aStream	"Answer an instance of me as described on the stream, aStream."		| value neg |	(aStream atEnd or: [aStream peek isLetter]) ifTrue: [^0].	neg := aStream peekFor: $-.	value := self readIntegerFrom: aStream radix: 10.	(aStream peekFor: $r)		ifTrue:			[| radix |			radix := value.			value := self readSmalltalkRadix: value from: aStream.			value := self checkForOldSyntax: radix with: value on: aStream]		ifFalse: [value := self readSmalltalkAndCFloat: value from: aStream].	^neg		ifTrue: [value negated]		ifFalse: [value]! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.285-04:00'!readSmalltalkRadix: t1 from: t2	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point 	to an incorrect position in the file. The file may have been modified after 	this method was updated."		t1 < 2 ifTrue: [^self error: #INVALIDRADIX << #dialogs >> 'INVALID RADIX'].	(t2 atEnd		or:			[(t2 peek digitValue				between: 0				and: t1 - 1) not])		ifTrue:			[t2 skip: -1.			^t1].	^self readIntegerFrom: t2 radix: t1! !!Number class methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.285-04:00'!zero	^ 0! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.285-04:00'!chooseFloatRepresentationFor: t1	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point 	to an incorrect position in the file. The file may have been modified after 	this method was updated."		^ Float! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.286-04:00'!differenceFromMatrix: aMatrix		^aMatrix collect: [:a | a - self]! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.287-04:00'!differenceFromVector: aVector		^aVector collect: [:a | a - self]! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.288-04:00'!dist: aNumber	^self < aNumber		ifTrue: [ aNumber - self ]		ifFalse: [ self - aNumber ]! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.288-04:00'!productFromMatrix: aMatrix		^aMatrix collect: [:a | a * self]! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.289-04:00'!productFromVector: aVector		^aVector collect: [:a | a * self]! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.29-04:00'!quotientFromMatrix: aMatrix		^aMatrix collect: [:a | a / self]! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.291-04:00'!quotientFromVector: aVector		^aVector collect: [:a | a / self]! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.292-04:00'!sumFromMatrix: aMatrix		^aMatrix collect: [:a | a + self]! !!Number methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.293-04:00'!sumFromVector: aVector		^aVector collect: [:a | a + self]! !!AIBidirectionalMap class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.293-04:00'!equalityNew: capacity		^self basicNew initialize: capacity type: Dictionary! !!AIBidirectionalMap class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.295-04:00'!identityNew		^self identityNew: 5! !!AIBidirectionalMap class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.295-04:00'!identityNew: capacity		^self basicNew initialize: capacity type: IdentityDictionary! !!AIBidirectionalMap class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.295-04:00'!new		^self new: 5! !!AIBidirectionalMap class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.296-04:00'!new: size		^self equalityNew: size! !!AIBidirectionalMap class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.298-04:00'!withIndicesAndElements: aCollection		| map |	map := self new: aCollection size * 3 // 2.	aCollection doWithIndex: [:each :index | map at: index put: each].	^map! !!AIBidirectionalMap methodsFor: 'adding' stamp: '2025-08-06T15:19:14.299-04:00'!add: anAssociation		self		at: anAssociation key		put: anAssociation value! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.301-04:00'!associations		^forwards associations asArray! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.301-04:00'!at: anObject		^self at: anObject ifAbsent: nil! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.304-04:00'!at: anObject ifAbsent: exceptionBlock		^forwards		at: anObject		ifAbsent: [backwards at: anObject ifAbsent: exceptionBlock]! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.306-04:00'!at: key put: value		(backwards includesKey: value)		ifTrue: [self error: 'Value already mapped'].	(forwards includesKey: key)		ifTrue: [backwards removeKey: (forwards at: key)].	forwards at: key put: value.	backwards at: value put: key.	"[ self checkInvariant ] assert."	^value! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.307-04:00'!atKey: key		^self atKey: key ifAbsent: nil! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.309-04:00'!atKey: key ifAbsent: exceptionBlock		^forwards at: key ifAbsent: exceptionBlock! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.31-04:00'!atKey: key ifAbsentPut: valueBlock		| value |	value := self atKey: key.	value == nil		ifTrue:			[value := self				at: key				put: valueBlock value].	^value! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.31-04:00'!atValue: value		^self atValue: value ifAbsent: nil! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.311-04:00'!atValue: value ifAbsent: exceptionBlock		^backwards at: value ifAbsent: exceptionBlock! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.312-04:00'!atValue: value ifAbsentPut: keyBlock		| key |	key := self atValue: value.	key == nil		ifTrue:			[self				at: (key := keyBlock value)				put: value].	^key! !!AIBidirectionalMap methodsFor: 'private' stamp: '2025-08-06T15:19:14.313-04:00'!checkInvariant		^forwards size = backwards size		and:			[(forwards keys \ backwards values) isEmpty				and: [(forwards values \ backwards keys) isEmpty]]! !!AIBidirectionalMap methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.314-04:00'!do: aBlock		forwards do: aBlock! !!AIBidirectionalMap methodsFor: 'testing' stamp: '2025-08-06T15:19:14.316-04:00'!includes: value		^forwards includes: value! !!AIBidirectionalMap methodsFor: 'testing' stamp: '2025-08-06T15:19:14.317-04:00'!includesKey: key		^backwards includes: key! !!AIBidirectionalMap methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.317-04:00'!initialize: capacity type: typeClass		forwards := typeClass new: capacity.	backwards := typeClass new: capacity.	[self checkInvariant] assert! !!AIBidirectionalMap methodsFor: 'copying' stamp: '2025-08-06T15:19:14.318-04:00'!postCopy	"Make sure to copy the contents fully."		super postCopy.	forwards := forwards copy.	backwards := backwards copy! !!AIBidirectionalMap methodsFor: 'removing' stamp: '2025-08-06T15:19:14.319-04:00'!remove: anObject ifAbsent: exceptionBlock		self shouldNotImplement! !!AIBidirectionalMap methodsFor: 'removing' stamp: '2025-08-06T15:19:14.32-04:00'!removeKey: key		^self		removeKey: key		ifAbsent: [self error: 'key not found']! !!AIBidirectionalMap methodsFor: 'removing' stamp: '2025-08-06T15:19:14.321-04:00'!removeKey: key ifAbsent: exceptionBlock		| value |	value := forwards removeKey: key ifAbsent: exceptionBlock.	backwards removeKey: value.	[self checkInvariant] assert.	^value! !!AIBidirectionalMap methodsFor: 'removing' stamp: '2025-08-06T15:19:14.322-04:00'!removeValue: value		^self		removeValue: value		ifAbsent: [self error: 'value not found']! !!AIBidirectionalMap methodsFor: 'removing' stamp: '2025-08-06T15:19:14.322-04:00'!removeValue: value ifAbsent: exceptionBlock		| key |	key := backwards removeKey: value ifAbsent: exceptionBlock.	forwards removeKey: key.	[self checkInvariant] assert.	^key! !!AIBidirectionalMap methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.324-04:00'!size		^forwards size! !!AIMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.324-04:00'!at: name		^self atKey: (self keyForName: name)! !!AIMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.327-04:00'!at: name ifAbsent: exceptionBlock		^self		atKey: (self keyForName: name ifAbsent: exceptionBlock)		ifAbsent: exceptionBlock! !!AIMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.337-04:00'!at: name ifPresent: unaryBlock		^unaryBlock		value:			(self				at: name				ifAbsent: [^self])! !!AIMapping methodsFor: 'accessing - key' stamp: '2025-08-06T15:19:14.338-04:00'!atKey: key		^self		atKey: key		ifAbsent: [self error: 'key not found']! !!AIMapping methodsFor: 'accessing - key' stamp: '2025-08-06T15:19:14.34-04:00'!atKey: aKey ifAbsent: exceptionBlock		^self subclassResponsibility! !!AIMapping methodsFor: 'application' stamp: '2025-08-06T15:19:14.341-04:00'!convertCollection: aSequencableCollection		| collection |	collection := aSequencableCollection species new.	self do: [:index | collection add: (aSequencableCollection at: index)].	^collection! !!AIMapping methodsFor: 'application' stamp: '2025-08-06T15:19:14.342-04:00'!convertMatrixColumnwise: aMatrix		^aMatrix species withAll: (AIMappedMatrix on: aMatrix columnMap: self)! !!AIMapping methodsFor: 'application' stamp: '2025-08-06T15:19:14.342-04:00'!convertMatrixRowwise: aMatrix		^aMatrix species withAll: (AIMappedMatrix on: aMatrix rowMap: self)! !!AIMapping methodsFor: 'application' stamp: '2025-08-06T15:19:14.343-04:00'!convertSquareMatrix: aMatrix		^aMatrix species withAll: (AIMappedMatrix on: aMatrix map: self)! !!AIMapping methodsFor: 'converting' stamp: '2025-08-06T15:19:14.344-04:00'!derive: aBlock		| derivate |	derivate := AISmartMapping new.	derivate setParent: self.	self do: [:index | (aBlock value: index) ifTrue: [derivate add: index]].	^derivate! !!AIMapping methodsFor: 'converting' stamp: '2025-08-06T15:19:14.346-04:00'!deriveWithNames: names		| derivate |	derivate := AISmartMapping new.	derivate setParent: self.	names do: [:name | derivate add: (self keyForName: name)].	^derivate! !!AIMapping methodsFor: 'testing' stamp: '2025-08-06T15:19:14.347-04:00'!includesIndex: index		self		keyOf: index		ifAbsent: [^false].	^true! !!AIMapping methodsFor: 'testing' stamp: '2025-08-06T15:19:14.348-04:00'!includesKey: key		self		atKey: key		ifAbsent: [^false].	^true! !!AIMapping methodsFor: 'testing' stamp: '2025-08-06T15:19:14.35-04:00'!includesName: name		self		at: name		ifAbsent: [^false].	^true! !!AIMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.351-04:00'!keyForName: name		^self		keyForName: name		ifAbsent: [self error: 'key not found']! !!AIMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.351-04:00'!keyForName: name ifAbsent: exceptionBlock		^self subclassResponsibility! !!AIMapping methodsFor: 'accessing - key' stamp: '2025-08-06T15:19:14.352-04:00'!keyOf: index		^self		keyOf: index		ifAbsent: [self error: 'value not found']! !!AIMapping methodsFor: 'accessing - key' stamp: '2025-08-06T15:19:14.353-04:00'!keyOf: anIndex ifAbsent: exceptionBlock		^self subclassResponsibility! !!AIMapping methodsFor: 'accessing - key' stamp: '2025-08-06T15:19:14.353-04:00'!keys		^self subclassResponsibility! !!AIMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.354-04:00'!nameForKey: key		^self subclassResponsibility! !!AIMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.354-04:00'!nameOf: index		^self nameForKey: (self keyOf: index)! !!AIMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.355-04:00'!nameOf: index ifAbsent: exceptionBlock		^self nameForKey: (self keyOf: index ifAbsent: exceptionBlock)! !!AIMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.356-04:00'!names		^self keys collect: [:key | self nameForKey: key]! !!AIMapping methodsFor: 'removing' stamp: '2025-08-06T15:19:14.356-04:00'!remove: oldObject ifAbsent: anExceptionBlock		self shouldNotImplement! !!AIMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.358-04:00'!size		^self subclassResponsibility! !!AIMapping methodsFor: 'converting' stamp: '2025-08-06T15:19:14.365-04:00'!with: aCollection derive: aBlock		^self derive: [:index | aBlock value: (aCollection at: index)]! !!AINameMapping class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.366-04:00'!new	^ super new		forEquality;		yourself! !!AINameMapping class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.367-04:00'!newUsing: aComparisonBlock	^ self new		initialize;		setComparisonBlock: aComparisonBlock;		yourself! !!AINameMapping methodsFor: 'adding' stamp: '2025-08-06T15:19:14.369-04:00'!add: name		(self includesName: name) ifTrue: [self error].	names addLast: name.	^self size! !!AINameMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.371-04:00'!atKey: key ifAbsent: exceptionBlock		^(key		between: 1		and: self size)		ifTrue: [key]		ifFalse: [exceptionBlock value]! !!AINameMapping methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.373-04:00'!do: aBlock		1		to: self size		do: [:each | aBlock value: each]! !!AINameMapping methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.375-04:00'!forEquality		self setComparisonBlock: [:a :b | a = b]! !!AINameMapping methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.375-04:00'!forIdentity		self setComparisonBlock: [:a :b | a == b]! !!AINameMapping methodsFor: 'testing' stamp: '2025-08-06T15:19:14.376-04:00'!includesName: name		^names anySatisfy: [:each | comparisonBlock value: each value: name]! !!AINameMapping methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.377-04:00'!initialize		names := OrderedCollection new! !!AINameMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.381-04:00'!keyForName: name ifAbsent: exceptionBlock	^ name isInteger		ifTrue: [ name ]		ifFalse: [ | idx |			idx := names findFirst: [ :each | comparisonBlock value: name value: each ].			idx isZero				ifTrue: [ exceptionBlock value ].			^ idx ]! !!AINameMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.381-04:00'!keyOf: anIndex ifAbsent: exceptionBlock		^self atKey: anIndex ifAbsent: exceptionBlock! !!AINameMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.381-04:00'!keys		^names! !!AINameMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.383-04:00'!nameForKey: key		^names at: key! !!AINameMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.384-04:00'!names		^names! !!AINameMapping methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.384-04:00'!setComparisonBlock: aComparisonBlock		^comparisonBlock := aComparisonBlock! !!AINameMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.384-04:00'!size		^names size! !!AINumberMapping class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.386-04:00'!new: aSize	^ self new		setSize: aSize;		yourself! !!AINumberMapping methodsFor: 'adding' stamp: '2025-08-06T15:19:14.387-04:00'!add: index	"Maps an index to the next free key.	If the index is already mapped, throws an error.	@post-condition: 		anIndex <= self indexSize.		self keyAt: anIndex = self size.		self indexAt: self size = anIndex.	"		index > self lastIndex		ifTrue: [forth changeSizeTo: index]		ifFalse: [(self includesIndex: index) ifTrue: [self error]].	back add: index.	forth		at: index		put: back size.	^index! !!AINumberMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.389-04:00'!atKey: key ifAbsent: exceptionBlock	"Returns index of an ordinal key,	that is maps backwards from new to old 'indices'."		^[back at: key]		on: Error		do: [:ex | exceptionBlock value]! !!AINumberMapping methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.39-04:00'!do: aBlock		back do: aBlock! !!AINumberMapping methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.392-04:00'!initialize	"Sets up instance variables.	back -- maps from ordinal keys to indices, ie. its values are indices (old indices).	forth -- maps from indices to ordinal keys, ie. its values are ordinal keys (new indices) and thus may be nil."		back := OrderedCollection new.	forth := OrderedCollection new! !!AINumberMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.392-04:00'!keyForName: name ifAbsent: exceptionBlock		^name isInteger		ifTrue: [name]		ifFalse: [exceptionBlock value]! !!AINumberMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.395-04:00'!keyOf: anIndex ifAbsent: exceptionBlock	"Returns ordinal key of a index.	that is maps forward from old to new indices."		^[(forth at: anIndex) ifNil: [exceptionBlock value]]		on: Error		do: [:ex | exceptionBlock value]! !!AINumberMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.396-04:00'!keys		^1 to: self size! !!AINumberMapping methodsFor: 'adding' stamp: '2025-08-06T15:19:14.397-04:00'!lastIndex		^forth size! !!AINumberMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.397-04:00'!nameForKey: key		self error: 'key not found'! !!AINumberMapping methodsFor: 'removing' stamp: '2025-08-06T15:19:14.397-04:00'!replaceAll: aCollection		self initialize.	self addAll: aCollection! !!AINumberMapping methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.399-04:00'!setSize: size		back := forth := 1 to: size! !!AINumberMapping methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.399-04:00'!size		^back size! !!AISmartMapping class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.401-04:00'!on: parent		^(self new)		setParent: parent;		yourself! !!AISmartMapping methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.403-04:00'!isRoot		^parent isNil! !!AISmartMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.404-04:00'!keyForName: name ifAbsent: exceptionBlock		^name isInteger		ifTrue: [name]		ifFalse:			[self isRoot				ifTrue: [exceptionBlock value]				ifFalse:					[self keyOf: (parent keyForName: name ifAbsent: exceptionBlock)]]! !!AISmartMapping methodsFor: 'accessing - name' stamp: '2025-08-06T15:19:14.406-04:00'!nameForKey: key		^self isRoot		ifTrue: [self error: 'key not found']		ifFalse: [parent nameForKey: (self atKey: key)]! !!AISmartMapping methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.407-04:00'!setParent: mapping		^parent := mapping! !!AIArrayVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.407-04:00'!new: size		^self basicNew: size! !!AIArrayVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.409-04:00'!at: index		^self basicAt: index! !!AIArrayVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.41-04:00'!at: index put: aNumber		^self basicAt: index put: aNumber! !!AIArrayVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.411-04:00'!size		^self basicSize! !!AIBooleanVector methodsFor: 'logical operations' stamp: '2025-08-06T15:19:14.414-04:00'!& booleanVector		[self size = booleanVector size] assert.	^(self class new: self size)		setBits: (self getBits bitAnd: booleanVector getBits);		yourself! !!AIBooleanVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.414-04:00'!at: index		^bits allMask: (1 bitShift: index - 1)! !!AIBooleanVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.416-04:00'!at: index put: boolean	^ bits := boolean		ifTrue: [ bits maskSet: 1 << (index - 1) ]		ifFalse: [ bits maskClear: 1 << (index - 1) ]! !!AIBooleanVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.417-04:00'!bits		^bits! !!AIBooleanVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.417-04:00'!getBits		^bits! !!AIBooleanVector methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.418-04:00'!initializeSize: aSize		bits := 0.	size := aSize! !!AIBooleanVector methodsFor: 'logical operations' stamp: '2025-08-06T15:19:14.418-04:00'!not		^(self class new: self size)		setBits: self getBits bitInvert;		yourself! !!AIBooleanVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.419-04:00'!setBits: integer		^bits := integer! !!AIBooleanVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.419-04:00'!size		^size! !!AIBooleanVector methodsFor: 'logical operations' stamp: '2025-08-06T15:19:14.422-04:00'!| booleanVector		[self size = booleanVector size] assert.	^(self class new: self size)		setBits: (self getBits bitOr: booleanVector getBits);		yourself! !!AIFloatVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.422-04:00'!new: size		^self basicNew: size "<< 2"! !!AIFloatVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.423-04:00'!at: anIndex		"^self floatAt: (anIndex bitShift: 2) - 3"	^ (self basicAt: anIndex) ! !!AIFloatVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.424-04:00'!at: anIndex put: aNumber		"^self		floatAt: (anIndex bitShift: 2) - 3		put: aNumber asFloat"			^ self basicAt: anIndex put: aNumber asFloat! !!AIFloatVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.426-04:00'!floatAt: byteIndex		<primitive: 548>	^self primitiveFailed! !!AIFloatVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.427-04:00'!floatAt: byteIndex put: float		<primitive: 549>	^self primitiveFailed	! !!AIFloatVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.427-04:00'!size		^self basicSize" >> 2"! !!AIMatrixPath class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.428-04:00'!column: columnIndex on: matrix		^(self new: matrix rowSize)		setMatrix: matrix;		setMapBlock: [:index | index @ columnIndex];		yourself! !!AIMatrixPath class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.431-04:00'!diagonalOn: matrix		[matrix isSquare] assert.	^(self new: matrix columnSize)		setMatrix: matrix;		setMapBlock: [:index | index @ index];		yourself! !!AIMatrixPath class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.431-04:00'!row: rowIndex on: matrix		^(self new: matrix columnSize)		setMatrix: matrix;		setMapBlock: [:index | rowIndex @ index];		yourself! !!AIMatrixPath methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.432-04:00'!at: index		^matrix atPoint: (mapBlock value: index)! !!AIMatrixPath methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.434-04:00'!at: index put: aNumber		^matrix		atPoint: (mapBlock value: index)		put: aNumber! !!AIMatrixPath methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.435-04:00'!initializeSize: aSize		^size := aSize! !!AIMatrixPath methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.436-04:00'!setMapBlock: aBlock		^mapBlock := aBlock! !!AIMatrixPath methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.436-04:00'!setMatrix: aMatrix		^matrix := aMatrix! !!AIMatrixPath methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.437-04:00'!size		^size! !!AIMatrixPath methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.438-04:00'!species		^matrix vectorSpecies! !!AISparseVector methodsFor: 'adding' stamp: '2025-08-06T15:19:14.438-04:00'!addLast		size := size + 1! !!AISparseVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.44-04:00'!at: anIndex		| spot |	spot := self internalIndexOf: anIndex.	^spot > 0		ifTrue: [(contents at: spot) value]		ifFalse: [0]! !!AISparseVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.441-04:00'!at: anIndex put: aNumber		aNumber isZero		ifTrue: [self removeValueAt: anIndex]		ifFalse: [self setValue: aNumber at: anIndex].	^aNumber! !!AISparseVector methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.442-04:00'!collect: aBlock	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a collection that is like 	the receiver.  Answer the new collection."		| newCollection newContents |	newCollection := self species withSize: self size.	newContents := contents		collect: [:each | each key -> (aBlock value: each value)].	newCollection initializeContents: newContents.	^newCollection! !!AISparseVector methodsFor: 'vector functions' stamp: '2025-08-06T15:19:14.444-04:00'!distByAngle: aVector		^1 - (self cosine: aVector)! !!AISparseVector methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.445-04:00'!doSparseWithIndex: aBlock		contents		do:			[:each | 			aBlock				value: each value				value: each key]! !!AISparseVector methodsFor: 'vector functions' stamp: '2025-08-06T15:19:14.449-04:00'!dotProduct: aVector		| sum otherValueBlock |	(aVector hasSize: self size) ifFalse: [^self noMatchError].	sum := 0.	otherValueBlock := aVector == self		ifTrue: [[:each :index | each]]		ifFalse: [[:each :index | aVector at: index]].	self		doSparseWithIndex:			[:each :index | sum := sum + (each * (otherValueBlock value: each value: index))].	^sum! !!AISparseVector methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.449-04:00'!initializeContents: anAssociationArray		contents := anAssociationArray! !!AISparseVector methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.449-04:00'!initializeSize: aSize	size := aSize.	contents := OrderedCollection new! !!AISparseVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.452-04:00'!internalIndexOf: anIndex	"Searchs for the internal index of anIndex with O(log n) using binary search, returns	either the internal index of anIndex or, if anIndex is not found, the negated internal 	index to be used for insertion."		| mid low high index0 |	low := 1.	high := contents size.	[mid := (high + low) // 2.	low > high]		whileFalse:			[index0 := contents at: mid.			index0 key <= anIndex				ifTrue:					[index0 key = anIndex						ifTrue: [^mid]						ifFalse: [low := mid + 1]]				ifFalse: [high := mid - 1]].	^low negated! !!AISparseVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.454-04:00'!removeValueAt: anIndex		| spot |	spot := self internalIndexOf: anIndex.	spot > 0 ifTrue: [contents removeIndex: spot]! !!AISparseVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.455-04:00'!setValue: aNumber at: anIndex		| spot |	spot := self internalIndexOf: anIndex.	spot > 0		ifTrue: [(contents at: spot) value: aNumber]		ifFalse:			[contents				add: anIndex -> aNumber				beforeIndex: spot negated]! !!AISparseVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.455-04:00'!size		^size! !!AISparseVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.465-04:00'!sparseSize		^contents size! !!AISparseVector methodsFor: 'mathematical functions' stamp: '2025-08-06T15:19:14.466-04:00'!sum		^contents		inject: 0		into: [:sum :each | sum + each value]! !!AIVector class methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.466-04:00'!browserIcon"Answer icon to be displayed with matrix classes."		^ nil! !!AIVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.467-04:00'!new		^self new: 0! !!AIVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.469-04:00'!new: aSize		^(self basicNew)		initializeSize: aSize;		yourself! !!AIVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.471-04:00'!new: aSize withAll: value		^(self new: aSize)		atAllPut: value;		yourself! !!AIVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.472-04:00'!readFromDenseText: aStream		| size vector |	size := Integer readFrom: aStream skipSeparators.	vector := self new: size.	1		to: size		do:			[:index | 			vector				at: index				"put: (Number readSmalltalkAndCSyntaxFrom: aStream skipSeparators)"				put: (Number readFrom: aStream skipSeparators)].	^vector! !!AIVector class methodsFor: 'constants access' stamp: '2025-08-06T15:19:14.473-04:00'!unity		^AIVectorCoercion with: 1! !!AIVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.473-04:00'!withAll: aCollection		^(self new: aCollection size)		atAllPut: aCollection;		yourself! !!AIVector class methodsFor: 'constants access' stamp: '2025-08-06T15:19:14.474-04:00'!zero		^AIVectorCoercion with: 0! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.474-04:00'!* aNumber		^aNumber productFromVector: self! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.476-04:00'!*= aNumber		^self		with: (self coerce: aNumber)		affect: [:a :b | a * b]! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.476-04:00'!+ aNumber		^aNumber sumFromVector: self! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.477-04:00'!+= aNumber		^self		with: (self coerce: aNumber)		affect: [:a :b | a + b]! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.477-04:00'!- aNumber		^aNumber differenceFromVector: self! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.48-04:00'!-= aNumber		^self		with: (self coerce: aNumber)		affect: [:a :b | a - b]! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.48-04:00'!/ aNumber		^aNumber quotientFromVector: self! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.483-04:00'!/= aNumber		^self		with: (self coerce: aNumber)		affect: [:a :b | a / b]! !!AIVector methodsFor: 'comparing' stamp: '2025-08-06T15:19:14.483-04:00'!< aMagnitude		self error: 'Vectors are not ordered'! !!AIVector methodsFor: 'comparing' stamp: '2025-08-06T15:19:14.485-04:00'!= vector		^self == vector		or:			[(vector isKindOf: AIVector)				and:					[(vector hasSize: self size)						and:							[self								with: vector								do: [:a :b | a = b ifFalse: [^false]].							true]]]! !!AIVector methodsFor: 'converting' stamp: '2025-08-06T15:19:14.487-04:00'!asVector		^self! !!AIVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.488-04:00'!at: index		^self subclassResponsibility! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.489-04:00'!at: index add: aNumber		^self		at: index		put: (self at: index) + aNumber! !!AIVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.49-04:00'!at: index ifNilPut: aBlock	"Answer the value at anIndex.  If the value is nil, set it to be	the result of evaluating valueBlock, and answer that value."		^(self at: index)		ifNil:			[self				at: index				put: aBlock value]! !!AIVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.49-04:00'!at: index put: aNumber		^self subclassResponsibility! !!AIVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.492-04:00'!atAllPut: collection	collection isCollection		ifTrue: [ self with: collection affect: [ :a :b | b ] ]		ifFalse: [ super atAllPut: collection ]! !!AIVector methodsFor: 'coercing' stamp: '2025-08-06T15:19:14.492-04:00'!coerce: aNumber		^AIVectorCoercion with: aNumber! !!AIVector methodsFor: 'copying' stamp: '2025-08-06T15:19:14.492-04:00'!copyEmpty		^self copyEmpty: self size! !!AIVector methodsFor: 'copying' stamp: '2025-08-06T15:19:14.494-04:00'!copyEmpty: size		^self species new: size! !!AIVector methodsFor: 'vector functions' stamp: '2025-08-06T15:19:14.494-04:00'!cosine: aVector		^self unitVector dotProduct: aVector unitVector! !!AIVector methodsFor: 'copying' stamp: '2025-08-06T15:19:14.495-04:00'!deepCopy		^self species withAll: self! !!AIVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.495-04:00'!defaultElement		^Float zero! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.496-04:00'!differenceFromDouble: aNumber		^self differenceFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.497-04:00'!differenceFromFixedPoint: aNumber		^self differenceFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.497-04:00'!differenceFromFloat: aNumber		^self differenceFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.505-04:00'!differenceFromFraction: aNumber		^self differenceFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.506-04:00'!differenceFromInteger: aNumber		^self differenceFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.507-04:00'!differenceFromNumber: aNumber		^self collect: [:b | aNumber - b]! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.507-04:00'!differenceFromPoint: aNumber		^self differenceFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.508-04:00'!differenceFromSmallDouble: aNumber		^self differenceFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.508-04:00'!differenceFromVector: aVector		^aVector		with: self		collect: [:a :b | a - b]! !!AIVector methodsFor: 'vector functions' stamp: '2025-08-06T15:19:14.512-04:00'!dist: aVector		| sum |	sum := 0.	self		with: aVector		do: [:a :b | sum := sum + ((a - b) ** 2)].	^sum! !!AIVector methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.514-04:00'!doSparseWithIndex: aBlock		self		doWithIndex:			[:each :index | each isZero ifFalse: [aBlock value: each value: index]].	^self! !!AIVector methodsFor: 'vector functions' stamp: '2025-08-06T15:19:14.516-04:00'!dotProduct: aVector	"comment stating purpose of message"		| sum |	(aVector hasSize: self size) ifFalse: [^self noMatchError].	sum := 0.	self		with: aVector		do: [:a :b | sum := sum + (a * b)].	^sum! !!AIVector methodsFor: 'coercing' stamp: '2025-08-06T15:19:14.516-04:00'!generality		^210! !!AIVector methodsFor: 'comparing' stamp: '2025-08-06T15:19:14.516-04:00'!hash	^ (self size hash bitXor: (self at: 1) hash) bitXor: (self at: self size) hash! !!AIVector methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.517-04:00'!initializeSize: aSize		^self subclassResponsibility! !!AIVector methodsFor: 'testing' stamp: '2025-08-06T15:19:14.518-04:00'!isZero	"comment stating purpose of message"		^self allSatisfy: #isZero! !!AIVector methodsFor: 'testing' stamp: '2025-08-06T15:19:14.519-04:00'!isZeroAt: index		^(self at: index) isZero! !!AIVector methodsFor: 'vector functions' stamp: '2025-08-06T15:19:14.519-04:00'!length	"comment stating purpose of message"		^(self dotProduct: self) sqrt! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.519-04:00'!negated	"comment stating purpose of message"		^self collect: #negated! !!AIVector methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.522-04:00'!noMatchError	self error: 'No match'! !!AIVector methodsFor: 'private' stamp: '2025-08-06T15:19:14.522-04:00'!noModificationError	self error: 'No modification'! !!AIVector methodsFor: 'vector functions' stamp: '2025-08-06T15:19:14.523-04:00'!normalize	"comment stating purpose of message"		| len |	len := self length.	len isZero		ifTrue: [self atAllPut: len]		ifFalse: [self /= self length].	^self! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.523-04:00'!productFromDouble: aVector		^self productFromNumber: aVector! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.523-04:00'!productFromFixedPoint: aVector		^self productFromNumber: aVector! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.523-04:00'!productFromFloat: aVector		^self productFromNumber: aVector! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.524-04:00'!productFromFraction: aVector		^self productFromNumber: aVector! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.525-04:00'!productFromInteger: aVector		^self productFromNumber: aVector! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.536-04:00'!productFromNumber: aNumber		^self collect: [:b | aNumber * b]! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.537-04:00'!productFromPoint: aVector		^self productFromNumber: aVector! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.537-04:00'!productFromSmallDouble: aVector		^self productFromNumber: aVector! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.547-04:00'!productFromVector: aVector		^aVector		with: self		collect: [:a :b | a * b]! !!AIVector methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.556-04:00'!putWithIndex: aBlock		1		to: self size		do:			[:index | 			self				at: index				put: (aBlock value: index)]! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.558-04:00'!quotientFromDouble: aNumber		^self quotientFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.559-04:00'!quotientFromFixedPoint: aNumber		^self quotientFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.559-04:00'!quotientFromFloat: aNumber		^self quotientFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.559-04:00'!quotientFromFraction: aNumber		^self quotientFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.559-04:00'!quotientFromInteger: aNumber		^self quotientFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.56-04:00'!quotientFromNumber: aNumber		^self collect: [:b | aNumber / b]! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.56-04:00'!quotientFromPoint: aNumber		^self quotientFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.56-04:00'!quotientFromSmallDouble: aNumber		^self quotientFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.56-04:00'!quotientFromVector: aVector		^aVector		with: self		collect: [:a :b | a / b]! !!AIVector methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.57-04:00'!reciprocal	"comment stating purpose of message"		^self collect: #reciprocal! !!AIVector methodsFor: 'testing' stamp: '2025-08-06T15:19:14.572-04:00'!respondsToArithmetic	"We are arithmetic, yes."		^true! !!AIVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.572-04:00'!size		^self subclassResponsibility! !!AIVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.574-04:00'!sparseSize		| tally |	tally := 0.	self doSparseWithIndex: [:each :index | tally := tally + 1].	^tally! !!AIVector methodsFor: 'mathematical functions' stamp: '2025-08-06T15:19:14.575-04:00'!sqrt		^self collect: #sqrt! !!AIVector methodsFor: 'printing' stamp: '2025-08-06T15:19:14.582-04:00'!storeDenseTextOn: aStream		aStream		print: self size;		cr.	self		do: [:each | aStream print: each]		separatedBy: [aStream space].	aStream cr! !!AIVector methodsFor: 'mathematical functions' stamp: '2025-08-06T15:19:14.583-04:00'!sum		^self		inject: 0		into: [:sum :each | sum + each]! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.583-04:00'!sumFromDouble: aNumber		^self sumFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.584-04:00'!sumFromFixedPoint: aNumber		^self sumFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.584-04:00'!sumFromFloat: aNumber		^self sumFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.584-04:00'!sumFromFraction: aNumber		^self sumFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.585-04:00'!sumFromInteger: aNumber		^self sumFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.585-04:00'!sumFromNumber: aNumber		^self collect: [:b | aNumber + b]! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.586-04:00'!sumFromPoint: aNumber		^self collect: [:b | aNumber + b]! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.586-04:00'!sumFromSmallDouble: aNumber		^self sumFromNumber: aNumber! !!AIVector methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.587-04:00'!sumFromVector: aVector		^aVector		with: self		collect: [:a :b | a + b]! !!AIVector methodsFor: 'vector functions' stamp: '2025-08-06T15:19:14.602-04:00'!unitVector	"comment stating purpose of message"		self isZero ifTrue: [^self].	^self / self length! !!AIVector methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.603-04:00'!with: vector affect: aBlock		(vector hasSize: self size) ifFalse: [^self noMatchError].	1		to: self size		do:			[:index | 			self				at: index				put:					(aBlock						value: (self at: index)						value: (vector at: index))].	^self! !!AIVector methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.616-04:00'!with: vector collect: aBlock		| newVector |	(vector hasSize: self size) ifFalse: [^self noMatchError].	newVector := self species new: self size.	1		to: self size		do:			[:index | 			newVector				at: index				put:					(aBlock						value: (self at: index)						value: (vector at: index))].	^newVector! !!AIVector methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.617-04:00'!with: vector do: aBlock		(vector hasSize: self size) ifFalse: [^self noMatchError].	1		to: self size		do:			[:index | 			aBlock				value: (self at: index)				value: (vector at: index)].	^self! !!AIVectorCoercion class methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.62-04:00'!with: aNumber		^(aNumber isKindOf: AIVector)		ifTrue: [aNumber]		ifFalse:			[(self basicNew)				setNumber: aNumber;				yourself]! !!AIVectorCoercion methodsFor: 'converting' stamp: '2025-08-06T15:19:14.622-04:00'!asNumber		^number! !!AIVectorCoercion methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.622-04:00'!at: index		^number! !!AIVectorCoercion methodsFor: 'testing' stamp: '2025-08-06T15:19:14.623-04:00'!hasSize: aSize		^true! !!AIVectorCoercion methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.624-04:00'!initializeSize: aSize		^self noDimensionError! !!AIVectorCoercion methodsFor: 'private' stamp: '2025-08-06T15:19:14.624-04:00'!noDimensionError		^self error: 'Coerced matrices do not have dimension.'! !!AIVectorCoercion methodsFor: 'printing' stamp: '2025-08-06T15:19:14.625-04:00'!printOn: aStream		aStream		print: self class;		nextPutAll: ' with: ';		print: number! !!AIVectorCoercion methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.626-04:00'!setNumber: aNumber		^number := aNumber! !!AIVectorCoercion methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.626-04:00'!size		^self noDimensionError! !!AIVectorCoercion methodsFor: 'mathematical functions' stamp: '2025-08-06T15:19:14.627-04:00'!sum		^self noDimensionError! !!AIVectorCoercion methodsFor: 'private' stamp: '2025-08-06T15:19:14.628-04:00'!switch: matrix caseCoercion: coercionBlock caseVector: vectorBlock		^(matrix isKindOf: AIVectorCoercion)		ifTrue: [coercionBlock value]		ifFalse: [vectorBlock value]! !!AIVectorCoercion methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.629-04:00'!with: vector affect: aBlock		^self		switch: vector		caseCoercion:			[number := aBlock				value: number				value: vector asNumber]		caseVector: [self error]! !!AIVectorCoercion methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.631-04:00'!with: vector collect: aBlock		^self		switch: vector		caseCoercion:			[AIMatrixCoercion				with:					(aBlock						value: number						value: vector asNumber)]		caseVector:			[vector				with: self				collect: [:a :b | aBlock value: b value: a]]! !!AIVectorCoercion methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.633-04:00'!with: vector do: aBlock		^self		switch: vector		caseCoercion:			[aBlock				value: number				value: vector asNumber]		caseVector:			[vector				with: self				do: [:a :b | aBlock value: b value: a]]! !!AIMappedVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.635-04:00'!on: aVector		^self on: aVector indices: nil! !!AIMappedVector class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.636-04:00'!on: aVector indices: aReindexing		^(super on: aVector)		setIndices: aReindexing;		yourself! !!AIMappedVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.637-04:00'!at: anIndex		^vector at: (indices at: anIndex)! !!AIMappedVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.637-04:00'!at: anIndex put: aNumber		^vector		at: (indices at: anIndex)		put: aNumber! !!AIMappedVector methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.64-04:00'!setIndices: aReindexing		indices := aReindexing ifNil: [AINumberMapping new: vector size]! !!AIMappedVector methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.64-04:00'!size		^indices size! !!AIVectorDecorator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.641-04:00'!on: aVector		^(self basicNew)		setVector: aVector asVector;		yourself! !!AIVectorDecorator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.643-04:00'!at: index		^vector at: index! !!AIVectorDecorator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.644-04:00'!at: index put: aNumber		^vector at: index put: aNumber! !!AIVectorDecorator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.644-04:00'!initializeSize: aSize		^self shouldNotImplement! !!AIVectorDecorator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.645-04:00'!setVector: aVector		^vector := aVector! !!AIVectorDecorator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.646-04:00'!size		^vector size! !!AIVectorDecorator methodsFor: 'private' stamp: '2025-08-06T15:19:14.647-04:00'!species		^vector species! !!TestCase methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.649-04:00'!assertBlock: aBlock raises: anExceptionalEvent		^[aBlock value.	false]		on: anExceptionalEvent		do: [:ex | ex return: true]! !!Integer methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.65-04:00'!coerce: t1	^ t1 asInteger! !!Integer methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.651-04:00'!maskClear: t1	^ self bitAnd: t1 bitInvert.! !!Integer methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.651-04:00'!maskSet: t1	^ self bitOr: t1.! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.652-04:00'!differenceFromMatrix: aMatrix		^aMatrix collect: [:a | a - self]! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.652-04:00'!differenceFromVector: aVector		^aVector collect: [:a | a - self]! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.654-04:00'!productFromMatrix: aMatrix		^aMatrix collect: [:a | a * self]! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.655-04:00'!productFromVector: aVector		^aVector collect: [:a | a * self]! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.656-04:00'!quotientFromMatrix: aMatrix		^aMatrix collect: [:a | a / self]! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.657-04:00'!quotientFromVector: aVector		^aVector collect: [:a | a / self]! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.657-04:00'!sumFromMatrix: aMatrix		^aMatrix collect: [:a | a + self]! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.658-04:00'!sumFromVector: aVector		^aVector collect: [:a | a + self]! !!Point methodsFor: '*AI-MooseLinearAlgebra' stamp: '2025-08-06T15:19:14.658-04:00'!transpose	^ y@x! !!AIAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.659-04:00'!extreme		^self		value: 0		using:			[:extreme :each | 			extreme abs > each abs				ifTrue: [extreme]				ifFalse: [each]]! !!AIAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.661-04:00'!maximum		^self		value: AIUnlimited negative		using: [:max :each | max max: each]! !!AIAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.662-04:00'!minimum		^self		value: AIUnlimited positive		using: [:min :each | min min: each]! !!AIAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.662-04:00'!new		self shouldNotImplement! !!AIAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.664-04:00'!squaredSum		^self		value: 0		using: [:sum :each | sum + each squared]! !!AIAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.665-04:00'!sum		^self		value: 0		using: [:sum :each | sum + each]! !!AIAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.666-04:00'!using: anAccumulationBlock		^self		value: Number zero		using: anAccumulationBlock! !!AIAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.667-04:00'!value: initialValue using: anAccumulationBlock		^(self basicNew)		setAccumulateBlock: anAccumulationBlock;		resetValue: initialValue;		yourself! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.667-04:00'!accumulate: aValue		size := size + 1.	^value := accumulateBlock value: value value: aValue! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.669-04:00'!accumulate: aValue withIndex: anIndex	size := size + 1.	^ value = (value := accumulateBlock value: value value: aValue)		ifFalse: [ index := anIndex ]! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.67-04:00'!add: aValue		^self accumulate: aValue! !!AIAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.671-04:00'!average		^value / size! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.672-04:00'!enumerate: aCollection		aCollection do: [:each | self accumulate: each].	^value! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.674-04:00'!enumerate: aCollection atAll: indices		indices do: [:key | self accumulate: (aCollection at: key)].	^value! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.675-04:00'!enumerate: aMatrix atAll: rowIndices andAll: columnIndices		rowIndices		do:			[:row | 			columnIndices				do: [:column | self accumulate: (aMatrix at: row and: column)]].	^value! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.675-04:00'!enumerateWithIndex: aSequencableCollection		aSequencableCollection		doWithIndex: [:each :index0 | self accumulate: each withIndex: index0].	^value! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.677-04:00'!from: start to: end do: aBlock		start		to: end		do: [:each | self accumulate: (aBlock value: each)].	^value! !!AIAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.677-04:00'!index		^index! !!AIAccumulator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.68-04:00'!merge: anAccumulator		size := size + anAccumulator size.	^self		accumulate: anAccumulator value		withIndex: anAccumulator index! !!AIAccumulator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.681-04:00'!resetValue: aValue		size := 0.	index := nil.	value := aValue! !!AIAccumulator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.682-04:00'!setAccumulateBlock: aBlock		accumulateBlock := aBlock! !!AIAccumulator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.682-04:00'!setValue: aValue	size := 0.	^ value! !!AIAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.682-04:00'!size		^size! !!AIAccumulator methodsFor: 'accumulate' stamp: '2025-08-06T15:19:14.684-04:00'!upTo: end do: aBlock		^self from: 1 to: end do: aBlock! !!AIAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.684-04:00'!value		^value! !!AIArrayMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.685-04:00'!at: row and: column		^array at: (row - 1) * self columnSize + column! !!AIArrayMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.686-04:00'!at: row and: column put: aNumber		^array		at: (row - 1) * self columnSize + column		put: aNumber! !!AIArrayMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.687-04:00'!checkInvariant		^array isCollection and: [(array size = rowSize) * columnSize]! !!AIArrayMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.688-04:00'!columnSize		^columnSize! !!AIArrayMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.688-04:00'!initializeRows: n columns: m		rowSize := n.	columnSize := m.	array := Array new: n * m.	^self! !!AIArrayMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.689-04:00'!rowSize		^rowSize! !!AIColumnMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.689-04:00'!onColumns: columnCollection	| new |	new := self basicNew.	new columns: columnCollection asArray.	[ new checkInvariant ] assert.	^ new! !!AIColumnMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.691-04:00'!at: row and: column		^(columns at: column) at: row! !!AIColumnMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.691-04:00'!at: row and: column put: aNumber		^(columns at: column) at: row put: aNumber! !!AIColumnMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.693-04:00'!checkInvariant		^columns isCollection		and:			[(columns allSatisfy: [:vector | vector isKindOf: self vectorSpecies])				and: [columns allSatisfy: [:vector | vector size = self rowSize]]]! !!AIColumnMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.694-04:00'!columnAt: column		^columns at: column! !!AIColumnMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.696-04:00'!columnSize		^columns size! !!AIColumnMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.696-04:00'!columns		^columns! !!AIColumnMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.697-04:00'!columns: anObject	columns := anObject! !!AIColumnMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.698-04:00'!initializeRows: m columns: n		columns := Array new: n.	1		to: n		do:			[:index | 			columns				at: index				put: (self vectorSpecies new: m)]! !!AIColumnMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.699-04:00'!rowSize		^columns isEmpty		ifTrue: [0]		ifFalse: [columns last size]! !!AISparseColumnMatrix class methodsFor: 'private' stamp: '2025-08-06T15:19:14.699-04:00'!vectorSpecies		^AISparseVector! !!AISparseColumnMatrix methodsFor: 'adding' stamp: '2025-08-06T15:19:14.699-04:00'!addColumn		columns := columns copyWith: (self vectorSpecies new: self rowSize)! !!AISparseColumnMatrix methodsFor: 'adding' stamp: '2025-08-06T15:19:14.7-04:00'!addRow		columns do: #addLast! !!AISparseColumnMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.702-04:00'!doSparseWithIndices: trinaryBlock		columns		doWithIndex:			[:vector :column | 			vector				doSparseWithIndex:					[:each :row | trinaryBlock value: each value: row value: column]].	^self! !!AISparseColumnMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.702-04:00'!isZeroAt: row and: column		^(columns at: column) isZeroAt: row! !!AISparseColumnMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.712-04:00'!sparseSize		^columns		inject: 0		into: [:sum :each | sum + each sparseSize]! !!AISparseColumnMatrix methodsFor: 'printing' stamp: '2025-08-06T15:19:14.714-04:00'!storeOn: stream		| text |	text := String new writeStream.	self storeSparseTextOn: text.	stream		print: self class;		space;		nextPutAll: #readFromSparseText:;		space;		print:				(text contents						replaceAll: Character cr						with: Character space);		space;		nextPutAll: 'readStream'! !!AIMatrix class methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.716-04:00'!browserIcon"Answer icon to be displayed with matrix classes."		^ nil! !!AIMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.716-04:00'!new	"Create a new matrix with dimension zero."		^self new: Number zero! !!AIMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.718-04:00'!new: numberOrPoint	"Create a new square matrix with the given dimension."		| point |	point := numberOrPoint asPoint.	^self		rows: point x		columns: point y! !!AIMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.719-04:00'!new: numberOrPoint withAll: value		^(self new: numberOrPoint)		atAllPut: value;		yourself! !!AIMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.721-04:00'!readFromDenseText: aStream	| m n matrix |	m := Integer readFrom: aStream skipSeparators.	n := Integer readFrom: aStream skipSeparators.	matrix := self rows: m columns: n.	1 to: m do: [ :row | 1 to: n do: [ :column | matrix at: row and: column put: (Number readFrom: aStream skipSeparators) ] ].	^ matrix! !!AIMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.724-04:00'!readFromSparseText: aStream		| m n matrix |	n := Integer readFrom: aStream skipSeparators.	m := Integer readFrom: aStream skipSeparators.	Integer readFrom: aStream skipSeparators.	matrix := self		rows: m		columns: n		withAll: Number zero.	1		to: m		do:			[:rows | 			1				to: (Integer readFrom: aStream skipSeparators)				do:					[:unused | 					matrix						at: rows						and: (Integer readFrom: aStream skipSeparators) + 1						put: (Number readFrom: aStream skipSeparators)]].	^matrix! !!AIMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.726-04:00'!rows: m columns: n	"Create a new matrix with m rows and n columns."		^(self basicNew)		initializeRows: m columns: n;		yourself! !!AIMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.727-04:00'!rows: m columns: n withAll: value		^(self rows: m columns: n)		atAllPut: value;		yourself! !!AIMatrix class methodsFor: 'private' stamp: '2025-08-06T15:19:14.73-04:00'!switch: anObject caseMatrix: matrixBlock caseNestedCollection: nestedColletionBlock caseCollection: collectionBlock default: defaultBlock	(anObject isKindOf: AIMatrix) ifTrue: [ ^ matrixBlock value ].		anObject isCollection		ifTrue: [ (anObject isNotEmpty and: [ anObject allSatisfy: [ :each | each isCollection and: [ each size = anObject first size ] ] ])				ifTrue: [ ^ nestedColletionBlock value ]				ifFalse: [ ^ collectionBlock value ] ].	^ defaultBlock value! !!AIMatrix class methodsFor: 'constants access' stamp: '2025-08-06T15:19:14.731-04:00'!unity		^AIMatrixCoercion with: 1! !!AIMatrix class methodsFor: 'private' stamp: '2025-08-06T15:19:14.732-04:00'!vectorSpecies		^AIArrayVector! !!AIMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.735-04:00'!withAll: object		| dimension |	dimension := self		switch: object		caseMatrix: [object dimension]		caseNestedCollection: [object size @ object first size]		caseCollection: [1 @ object size]		default: [0].	^(self new: dimension)		atAllPut: object;		yourself! !!AIMatrix class methodsFor: 'constants access' stamp: '2025-08-06T15:19:14.736-04:00'!zero		^AIMatrixCoercion with: 0! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.736-04:00'!* aNumber		^aNumber productFromMatrix: self! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.737-04:00'!*= aNumber		^self		with: (self coerce: aNumber)		affect: [:a :b | a * b]! !!AIMatrix methodsFor: 'matrix functions' stamp: '2025-08-06T15:19:14.741-04:00'!*~ aMatrix	"Answer the matrix multiplication of the reciever with the argument."		| newMatrix |	self columnSize = aMatrix rowSize ifFalse: [Array new noMatchError].	newMatrix := self species		rows: self rowSize		columns: aMatrix columnSize.	"workaround: this should be done in a more generic way with double dispatch."	newMatrix		putWithIndices:			((aMatrix isKindOf: AIDiagonalMatrix)				ifTrue: [[:i :j | (self at: i and: j) * (aMatrix at: j and: j)]]				ifFalse:					[[:i :j | 					(1 to: self columnSize)						inject: 0						into:							[:sum :k | sum + ((self at: i and: k) * (aMatrix at: k and: j))]]]).	^newMatrix! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.741-04:00'!+ aNumber		^aNumber sumFromMatrix: self! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.743-04:00'!+= aNumber		^self		with: (self coerce: aNumber)		affect: [:a :b | a + b]! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.743-04:00'!- aNumber		^aNumber differenceFromMatrix: self! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.745-04:00'!-= aNumber		^self		with: (self coerce: aNumber)		affect: [:a :b | a - b]! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.745-04:00'!/ aNumber		^aNumber quotientFromMatrix: self! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.747-04:00'!/= aNumber		^self		with: (self coerce: aNumber)		affect: [:a :b | a / b]! !!AIMatrix methodsFor: 'comparing' stamp: '2025-08-06T15:19:14.748-04:00'!= matrix	"Answer whether the dimension of the receiver is the same as otherMatrix' dimension,	and each of the receiver's elements equal the corresponding element of otherMatrix."		^self == matrix		or:			[(matrix isKindOf: AIMatrix)				and:					[(matrix hasDimension: self dimension)						and:							[self								with: matrix								do: [:a :b | a = b ifFalse: [^false]].							true]]]! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.751-04:00'!adaptToNumber: rcvr andSend: selector	^ self perform: selector with: rcvr! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.751-04:00'!adaptToPoint: rcvr andSend: selector	^ self perform: selector with: rcvr! !!AIMatrix methodsFor: 'resizing' stamp: '2025-08-06T15:19:14.753-04:00'!addColumn	"Add a column. Must implement if isExtendable returns true."		self shouldNotImplement! !!AIMatrix methodsFor: 'resizing' stamp: '2025-08-06T15:19:14.753-04:00'!addColumnBeforeIndex: anIndex	"Insert a column before anIndex. Must implement if isResizebale returns true."		self shouldNotImplement! !!AIMatrix methodsFor: 'resizing' stamp: '2025-08-06T15:19:14.754-04:00'!addRow	"Add a row. Must implement if isExtendable returns true."		self shouldNotImplement! !!AIMatrix methodsFor: 'resizing' stamp: '2025-08-06T15:19:14.754-04:00'!addRowBeforeIndex: anIndex	"Insert a row before anIndex. Must implement if isResizebale returns true."		self shouldNotImplement! !!AIMatrix methodsFor: 'converting' stamp: '2025-08-06T15:19:14.755-04:00'!asArray		| array stream |	array := Array new: self rowSize * self columnSize.	stream := WriteStream on: array.	self do: [:each | stream nextPut: each].	^array! !!AIMatrix methodsFor: 'printing' stamp: '2025-08-06T15:19:14.756-04:00'!asDenseString	" Answer a <String> complete (or dense) representation of the receiver "	^ (String streamContents: [ : stream | 		self storeDenseTextOn: stream ]) 			allButFirst: 4.! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.757-04:00'!at: row and: column	"Answer the vakue at the given indices."		^self subclassResponsibility! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.757-04:00'!at: row and: column add: aNumber	"Add aNumber to the element at row and column.  Answer the sum."		^self		at: row		and: column		put: (self at: row and: column) + aNumber! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.759-04:00'!at: row and: column divide: aNumber	"Divide the element at row and column by aNumber.  Answer the quotient."		^self		at: row		and: column		put: (self at: row and: column) / aNumber! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.76-04:00'!at: row and: column multiply: aNumber	"Multiply aNumber with the element at row and column.  Answer the product."		^self		at: row		and: column		put: (self at: row and: column) * aNumber! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.76-04:00'!at: row and: column put: aNumber	"Store the vakue at the given indices."		^self subclassResponsibility! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.761-04:00'!at: row and: column subtract: aNumber	"Subtract aNumber from the element at row and column.  Answer the difference."		^self		at: row		and: column		put: (self at: row and: column) - aNumber! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.769-04:00'!atAllPut: object		self class		switch: object		caseMatrix:			[self				with: object				affect: [:a :b | b]]		caseNestedCollection:			[object size = self rowSize				ifTrue:					[[object first size = self columnSize] assert.					self putWithIndices: [:row :column | (object at: row) at: column]]				ifFalse:					[object size = self columnSize						ifTrue:							[[object first size = self rowSize] assert.							self putWithIndices: [:row :column | (object at: column) at: row]]						ifFalse: [self error]]]		caseCollection:			[| stream |			[object size = (self rowSize * self columnSize)] assert.			stream := ReadStream on: object.			self				withIndices:					[:row :column | 					self						at: row						and: column						put: stream next]]		default:			[self withIndices: [:row :column | self at: row and: column put: object]].	^object! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.776-04:00'!atPoint: rowColumnCoordinate		^self		at: rowColumnCoordinate x		and: rowColumnCoordinate y! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.777-04:00'!atPoint: rowColumnCoordinate put: aNumber		^self		at: rowColumnCoordinate x		and: rowColumnCoordinate y		put: aNumber! !!AIMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.777-04:00'!checkInvariant		^self subclassResponsibility! !!AIMatrix methodsFor: 'coercing' stamp: '2025-08-06T15:19:14.778-04:00'!coerce: aNumber		^AIMatrixCoercion with: aNumber! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.779-04:00'!collect: aBlock		| newMatrix |	newMatrix := self copyEmpty.	self		withIndices:			[:row :column | 			newMatrix				at: row				and: column				put: (aBlock value: (self at: row and: column))].	^newMatrix! !!AIMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.781-04:00'!columnAt: columnIndex		^AIMatrixPath column: columnIndex on: self! !!AIMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.782-04:00'!columnAt: columnIndex put: vector		vector doWithIndex: [:each :row | self at: row and: columnIndex put: each].	^vector! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.782-04:00'!columnSize		^self subclassResponsibility! !!AIMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.784-04:00'!columns		| array |	array := Array new: self columnSize.	1		to: self columnSize		do:			[:index | 			array				at: index				put: (self columnAt: index)].	^array! !!AIMatrix methodsFor: 'copying' stamp: '2025-08-06T15:19:14.784-04:00'!copyEmpty	"Answer a copy of the receiver that contains no elements."		^self copyEmpty: self dimension! !!AIMatrix methodsFor: 'copying' stamp: '2025-08-06T15:19:14.785-04:00'!copyEmpty: dimension	"Answer a copy of the receiver that contains no elements."		^self species new: dimension! !!AIMatrix methodsFor: 'copying' stamp: '2025-08-06T15:19:14.785-04:00'!deepCopy		^self species withAll: self! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.785-04:00'!density		^self sparseSize / self size! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.788-04:00'!determinant		| a11 a12 a21 a22 |	[self hasDimension: 2 @ 2] assert.	a11 := self atPoint: 1 @ 1.	a12 := self atPoint: 1 @ 2.	a21 := self atPoint: 2 @ 1.	a22 := self atPoint: 2 @ 2.	^a11 * a22 - (a12 * a21)! !!AIMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.788-04:00'!diagonal		^AIMatrixPath diagonalOn: self! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.788-04:00'!differenceFromDouble: aNumber		^self differenceFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.79-04:00'!differenceFromFixedPoint: aNumber		^self differenceFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.79-04:00'!differenceFromFloat: aNumber		^self differenceFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.79-04:00'!differenceFromFraction: aNumber		^self differenceFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.791-04:00'!differenceFromInteger: aNumber		^self differenceFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.791-04:00'!differenceFromMatrix: aMatrix		^aMatrix		with: self		collect: [:a :b | a - b]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.792-04:00'!differenceFromNumber: aNumber		^self collect: [:b | aNumber - b]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.792-04:00'!differenceFromPoint: aNumber		^self differenceFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.793-04:00'!differenceFromSmallDouble: aNumber		^self differenceFromNumber: aNumber! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.801-04:00'!dimension		^self rowSize @ self columnSize! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.802-04:00'!do: aBlock		self		withIndices: [:row :column | aBlock value: (self at: row and: column)].	^self! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.805-04:00'!doSparseWithIndices: eachRowColumnBlock		self		doWithIndices:			[:each :row :column | 			each isZero				ifFalse: [eachRowColumnBlock value: each value: row value: column]].	^self! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.806-04:00'!doWithIndices: eachRowColumnBlock		self		withIndices:			[:row :column | 			eachRowColumnBlock				value: (self at: row and: column)				value: row				value: column]! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.807-04:00'!first		^self at: 1 and: 1! !!AIMatrix methodsFor: 'coercing' stamp: '2025-08-06T15:19:14.807-04:00'!generality		^240! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.808-04:00'!hasDimension: aDimension		^self dimension = aDimension! !!AIMatrix methodsFor: 'comparing' stamp: '2025-08-06T15:19:14.809-04:00'!hash		^(self dimension hash bitXor: (self at: 1) hash)		bitXor: (self at: self dimension) hash! !!AIMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.811-04:00'!initializeRows: m columns: n		^self subclassResponsibility! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.813-04:00'!inject: value into: aBlock		| result |	result := value.	self do: [:each | result := aBlock value: result value: each].	^result! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.814-04:00'!isComplex		^false! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.816-04:00'!isDiagonal	"Answer if the reciever is a diagonal matrix."		self isSquare ifFalse: [^false].	self		doSparseWithIndices:			[:value :row :column | row = column ifFalse: [^false]].	^true! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.817-04:00'!isResizeable		^false! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.817-04:00'!isSquare	"Answer if the reciever is a square matrix."		^self rowSize = self columnSize! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.819-04:00'!isSymetric	"Answer if the reciever is a symetric matrix."		self isSquare ifFalse: [^false].	1		to: self columnSize		do:			[:column | 			1				to: column				do:					[:row | (self at: column and: row) = (self at: row and: column) ifFalse: [^false]]].	^true! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.819-04:00'!isZero	"Answer if the reciever contains no non-zero numbers."		self doSparseWithIndices: [:value :row :column | ^false].	^true! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.822-04:00'!isZeroAt: row and: column		^(self at: row and: column) isZero! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.83-04:00'!last		^self		at: self rowSize		and: self columnSize! !!AIMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.831-04:00'!noMatchError	self error: 'No match'! !!AIMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.832-04:00'!noModificationError	self error: 'No modification'! !!AIMatrix methodsFor: 'printing' stamp: '2025-08-06T15:19:14.836-04:00'!printOn: aStream	"Append to the argument aStream a sequence of characters that identifies the matrix."	| tooMany |	tooMany := aStream position + 5000.	aStream		print: self class;		space;		print: self dimension;		space;		nextPut: $(.	(1 to: self rowSize)		do: [ :row | 			aStream nextPut: $(.			(1 to: self columnSize)				do: [ :column | 					aStream position > tooMany						ifTrue: [ aStream								nextPutAll: '...etc...';								nextPutAll: '))'.							^ self ].					aStream print: (self at: row and: column) ]				separatedBy: [ aStream space ].			aStream nextPut: $) ]		separatedBy: [ aStream space ].	aStream nextPut: $)! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.837-04:00'!productFromDouble: aNumber		^self productFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.838-04:00'!productFromFixedPoint: aNumber		^self productFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.839-04:00'!productFromFloat: aNumber		^self productFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.839-04:00'!productFromFraction: aNumber		^self productFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.839-04:00'!productFromInteger: aNumber		^self productFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.841-04:00'!productFromMatrix: aMatrix		^aMatrix		with: self		collect: [:a :b | a * b]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.841-04:00'!productFromNumber: aNumber		^self collect: [:b | aNumber * b]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.842-04:00'!productFromPoint: aNumber		^self productFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.842-04:00'!productFromSmallDouble: aNumber		^self productFromNumber: aNumber! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.843-04:00'!putWithIndices: rowColumnBlock		self		withIndices:			[:row :column | 			self				at: row				and: column				put: (rowColumnBlock value: row value: column)].	^self! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.844-04:00'!quotientFromDouble: aNumber		^self quotientFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.844-04:00'!quotientFromFixedPoint: aNumber		^self quotientFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.845-04:00'!quotientFromFloat: aNumber		^self quotientFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.845-04:00'!quotientFromFraction: aNumber		^self quotientFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.846-04:00'!quotientFromInteger: aNumber		^self quotientFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.847-04:00'!quotientFromMatrix: aMatrix		^aMatrix		with: self		collect: [:a :b | a / b]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.848-04:00'!quotientFromNumber: aNumber		^self collect: [:b | aNumber / b]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.849-04:00'!quotientFromPoint: aNumber		^self quotientFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.849-04:00'!quotientFromSmallDouble: aNumber		^self quotientFromNumber: aNumber! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.851-04:00'!reciprocal		^self		collect:			[:each | 			each isZero				ifTrue: [each]				ifFalse: [each reciprocal]]! !!AIMatrix methodsFor: 'converting' stamp: '2025-08-06T15:19:14.852-04:00'!remap: mapping		^AIMappedMatrix on: self rowMap: mapping columnMap: mapping! !!AIMatrix methodsFor: 'resizing' stamp: '2025-08-06T15:19:14.852-04:00'!removeColumnAtIndex: anIndex		self shouldNotImplement! !!AIMatrix methodsFor: 'resizing' stamp: '2025-08-06T15:19:14.853-04:00'!removeRowAtIndex: anIndex		self shouldNotImplement! !!AIMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.853-04:00'!respondsToArithmetic	"We are arithmetic, yes."		^true! !!AIMatrix methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:14.853-04:00'!roundTo: aNumber		^self collect: [:each | each roundTo: aNumber]! !!AIMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.854-04:00'!rowAt: rowIndex		^AIMatrixPath row: rowIndex on: self! !!AIMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.856-04:00'!rowAt: rowIndex put: vector		vector		doWithIndex: [:each :column | self at: rowIndex and: column put: each].	^vector! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.872-04:00'!rowSize		^self subclassResponsibility! !!AIMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.875-04:00'!rows		| array |	array := Array new: self rowSize.	1		to: self rowSize		do:			[:index | 			array				at: index				put: (self rowAt: index)].	^array! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.875-04:00'!size		^self rowSize * self columnSize! !!AIMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.878-04:00'!sparseSize		| tally |	tally := 0.	self do: [:each | each isZero ifTrue: [tally := tally + 1]].	^tally! !!AIMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.879-04:00'!species		^self class! !!AIMatrix methodsFor: 'printing' stamp: '2025-08-06T15:19:14.883-04:00'!storeDenseTextOn: aStream	"Append to the argument aStream a sequence of characters 	that identifies the collection."		aStream		print: self rowSize;		space;		print: self columnSize;		cr.	1		to: self rowSize		do:			[:row | 			(1 to: self columnSize)				do: [:column | aStream print: (self at: row and: column)]				separatedBy: [aStream space].			aStream cr]! !!AIMatrix methodsFor: 'printing' stamp: '2025-08-06T15:19:14.884-04:00'!storeSparseTextOn: aStream	"Append to the argument aStream a sequence of characters 	that identifies the collection."		aStream		print: self columnSize;		space;		print: self rowSize;		space;		print: self sparseSize;		cr.	self rows		do:			[:row | 			aStream				print: row sparseSize;				cr.			row				doSparseWithIndex:					[:value :index | 					aStream						print: index - 1;						space;						print: value;						cr]]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.886-04:00'!sumFromDouble: aNumber		^self sumFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.886-04:00'!sumFromFixedPoint: aNumber		^self sumFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.887-04:00'!sumFromFloat: aNumber		^self sumFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.888-04:00'!sumFromFraction: aNumber		^self sumFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.888-04:00'!sumFromInteger: aNumber		^self sumFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.889-04:00'!sumFromMatrix: aMatrix		^aMatrix		with: self		collect: [:a :b | a + b]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.89-04:00'!sumFromNumber: aNumber		^self collect: [:b | aNumber + b]! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.891-04:00'!sumFromPoint: aNumber		^self sumFromNumber: aNumber! !!AIMatrix methodsFor: 'double dispatching' stamp: '2025-08-06T15:19:14.891-04:00'!sumFromSmallDouble: aNumber		^self sumFromNumber: aNumber! !!AIMatrix methodsFor: 'matrix functions' stamp: '2025-08-06T15:19:14.891-04:00'!transposed		^AIMatrixView transposeOn: self! !!AIMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.892-04:00'!vectorSpecies		^self class vectorSpecies! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.893-04:00'!with: aMatrix affect: eachOtherBlock		[aMatrix hasDimension: self dimension] assert.	self		putWithIndices:			[:row :column | 			eachOtherBlock				value: (self at: row and: column)				value: (aMatrix at: row and: column)]! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.895-04:00'!with: aMatrix collect: eachOtherBlock		| newMatrix |	[aMatrix hasDimension: self dimension] assert.	newMatrix := self copyEmpty: self dimension.	newMatrix		putWithIndices:			[:row :column | 			eachOtherBlock				value: (self at: row and: column)				value: (aMatrix at: row and: column)].	^newMatrix! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.897-04:00'!with: aMatrix do: eachOtherBlock		[aMatrix hasDimension: self dimension] assert.	self		withIndices:			[:row :column | 			eachOtherBlock				value: (self at: row and: column)				value: (aMatrix at: row and: column)]! !!AIMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.899-04:00'!withIndices: aBlock		1		to: self rowSize		do:			[:row | 			1				to: self columnSize				do: [:column | aBlock value: row value: column]]! !!AIMatrixCoercion class methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.9-04:00'!with: aNumber		^(aNumber isKindOf: AIMatrix)		ifTrue: [aNumber]		ifFalse:			[(self basicNew)				setNumber: aNumber;				yourself]! !!AIMatrixCoercion methodsFor: 'comparing' stamp: '2025-08-06T15:19:14.902-04:00'!= matrix		^self		switch: matrix		caseCoercion: [number = matrix asNumber]		caseMatrix: [matrix = self]! !!AIMatrixCoercion methodsFor: 'converting' stamp: '2025-08-06T15:19:14.904-04:00'!asNumber		^number! !!AIMatrixCoercion methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.904-04:00'!at: row and: column		^number! !!AIMatrixCoercion methodsFor: 'private' stamp: '2025-08-06T15:19:14.904-04:00'!checkInvariant		^number respondsToArithmetic! !!AIMatrixCoercion methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.905-04:00'!columnSize		self noDimensionError! !!AIMatrixCoercion methodsFor: 'testing' stamp: '2025-08-06T15:19:14.905-04:00'!hasDimension: aDimension		^true! !!AIMatrixCoercion methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.906-04:00'!initializeRows: m columns: n		^self noDimensionError! !!AIMatrixCoercion methodsFor: 'private' stamp: '2025-08-06T15:19:14.906-04:00'!noDimensionError		^self error: 'Coerced matrices do not have dimension.'! !!AIMatrixCoercion methodsFor: 'printing' stamp: '2025-08-06T15:19:14.907-04:00'!printOn: aStream	"Append to the argument aStream a sequence of characters that identifies the matrix."		aStream		print: self class;		nextPutAll: ' with: ';		print: number! !!AIMatrixCoercion methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.909-04:00'!rowSize		self noDimensionError! !!AIMatrixCoercion methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.91-04:00'!setNumber: aNumber		^number := aNumber! !!AIMatrixCoercion methodsFor: 'private' stamp: '2025-08-06T15:19:14.911-04:00'!switch: matrix caseCoercion: coercionBlock caseMatrix: matrixBlock		^(matrix isKindOf: AIMatrixCoercion)		ifTrue: [coercionBlock value]		ifFalse: [matrixBlock value]! !!AIMatrixCoercion methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.913-04:00'!with: matrix affect: aBlock		^self		switch: matrix		caseCoercion:			[number := aBlock				value: number				value: matrix asNumber]		caseMatrix: [self error]! !!AIMatrixCoercion methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.915-04:00'!with: matrix collect: aBlock		^self		switch: matrix		caseCoercion:			[AIMatrixCoercion				with:					(aBlock						value: number						value: matrix asNumber)]		caseMatrix:			[matrix				with: self				collect: [:a :b | aBlock value: b value: a]]! !!AIMatrixCoercion methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.918-04:00'!with: matrix do: aBlock		^self		switch: matrix		caseCoercion:			[aBlock				value: number				value: matrix asNumber]		caseMatrix:			[matrix				with: self				do: [:a :b | aBlock value: b value: a]]! !!AIMappedMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.919-04:00'!on: aMatrix		^self on: aMatrix rowMap: nil columnMap: nil! !!AIMappedMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.92-04:00'!on: aMatrix columnMap: columnReindexing		^self on: aMatrix rowMap: nil columnMap: columnReindexing! !!AIMappedMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.921-04:00'!on: aMatrix map: aReindexing		[aMatrix isSquare] assert.	^self on: aMatrix rowMap: aReindexing columnMap: aReindexing! !!AIMappedMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.922-04:00'!on: aMatrix rowMap: rowReindexing		^self on: aMatrix rowMap: rowReindexing columnMap: nil! !!AIMappedMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.922-04:00'!on: aMatrix rowMap: rowReindexing columnMap: columnReindexing		^(super on: aMatrix)		setRowMap: rowReindexing;		setColumnMap: columnReindexing;		yourself! !!AIMappedMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.923-04:00'!at: row and: column		^matrix		at: (rowMap at: row)		and: (columnMap at: column)! !!AIMappedMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.925-04:00'!at: row and: column put: aNumber		^matrix		at: (rowMap at: row)		and: (columnMap at: column)		put: aNumber! !!AIMappedMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.926-04:00'!columnSize		^columnMap size! !!AIMappedMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.926-04:00'!rowSize		^rowMap size! !!AIMappedMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.926-04:00'!setColumnMap: mapping		columnMap := mapping ifNil: [AINumberMapping new: matrix columnSize]! !!AIMappedMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.927-04:00'!setRowMap: mapping		rowMap := mapping ifNil: [AINumberMapping new: matrix rowSize]! !!AIMatrixDecorator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.928-04:00'!on: aMatrix		^(self basicNew)		setMatrix: aMatrix;		yourself! !!AIMatrixDecorator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.928-04:00'!at: row and: column		^matrix at: row and: column! !!AIMatrixDecorator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.93-04:00'!at: row and: column put: aNumber		^matrix at: row and: column put: aNumber! !!AIMatrixDecorator methodsFor: 'private' stamp: '2025-08-06T15:19:14.93-04:00'!checkInvariant		^matrix checkInvariant! !!AIMatrixDecorator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.93-04:00'!columnSize		^matrix columnSize! !!AIMatrixDecorator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.931-04:00'!initializeRows: m columns: n		self shouldNotImplement! !!AIMatrixDecorator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.932-04:00'!rowSize		^matrix rowSize! !!AIMatrixDecorator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.932-04:00'!setMatrix: aMatrix		^matrix := aMatrix! !!AIMatrixDecorator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.932-04:00'!species		^matrix species! !!AIMatrixView class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.934-04:00'!from: top to: bottom on: matrix		^(self new: bottom - top + 1)		setMatrix: matrix;		setMapBlock: [:row :column | row @ column - top + 1];		yourself! !!AIMatrixView class methodsFor: 'As yet unclassified' stamp: '2025-08-06T15:19:14.935-04:00'!fromColumn: start to: end on: matrix		^self		from: 1		to: matrix rowSize @ end		on: matrix! !!AIMatrixView class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.937-04:00'!transposeOn: matrix		^(self new: matrix dimension transpose)		setMatrix: matrix;		setMapBlock: [:row :column | column @ row];		yourself! !!AIMatrixView methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.937-04:00'!at: row and: column		^matrix atPoint: (mapBlock value: row value: column)! !!AIMatrixView methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.937-04:00'!at: row and: column put: aNumber		self noModificationError! !!AIMatrixView methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.938-04:00'!columnSize		^columnSize! !!AIMatrixView methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.938-04:00'!initializeRows: m columns: n		rowSize := m.	columnSize := n! !!AIMatrixView methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.938-04:00'!rowSize		^rowSize! !!AIMatrixView methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.94-04:00'!setMapBlock: block		^mapBlock := block! !!AIUnboundedMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.941-04:00'!on: matrix with: defaultValue		^(self on: matrix)		backgroundValue: defaultValue;		yourself! !!AIUnboundedMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.941-04:00'!at: row and: column		^[matrix at: row and: column]		on: "SubscriptOutOfBoundsError" Error		do: [:ex | backgroundValue]! !!AIUnboundedMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.943-04:00'!at: row and: column put: aNumber		^[matrix at: row and: column put: aNumber]		on: "SubscriptOutOfBoundsError" Error		do: [:ex | backgroundValue]! !!AIUnboundedMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.943-04:00'!backgroundValue		^backgroundValue! !!AIUnboundedMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.944-04:00'!backgroundValue: anObject		backgroundValue := anObject! !!AIRowMatrix class methodsFor: 'private' stamp: '2025-08-06T15:19:14.945-04:00'!onRows: rowCollection	| new |	new := self basicNew.	new rows: rowCollection asArray.	[ new checkInvariant ] assert.	^ new! !!AIRowMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.946-04:00'!at: row and: column		^(rows at: row) at: column! !!AIRowMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.948-04:00'!at: row and: column put: aNumber		^(rows at: row) at: column put: aNumber! !!AIRowMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.956-04:00'!checkInvariant		^rows isCollection		and:			[(rows allSatisfy: [:row | row isKindOf: self vectorSpecies])				and: [rows allSatisfy: [:row | row size = self columnSize]]]! !!AIRowMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.957-04:00'!columnSize		^rows isEmpty		ifTrue: [0]		ifFalse: [rows first size]! !!AIRowMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.958-04:00'!initializeRows: m columns: n		rows := Array new: m.	1		to: m		do:			[:index | 			rows				at: index				put: (self vectorSpecies new: n)]! !!AIRowMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.958-04:00'!rowAt: rowIndex		^rows at: rowIndex! !!AIRowMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.96-04:00'!rowSize		^rows size! !!AIRowMatrix methodsFor: 'accessing vectorwise' stamp: '2025-08-06T15:19:14.96-04:00'!rows		^rows! !!AIRowMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.961-04:00'!rows: anObject	rows := anObject! !!AISparseRowMatrix class methodsFor: 'private' stamp: '2025-08-06T15:19:14.961-04:00'!vectorSpecies		^AISparseVector! !!AISparseRowMatrix methodsFor: 'adding' stamp: '2025-08-06T15:19:14.962-04:00'!addColumn		rows do: #addLast! !!AISparseRowMatrix methodsFor: 'adding' stamp: '2025-08-06T15:19:14.962-04:00'!addRow		rows := rows copyWith: (self vectorSpecies new: self columnSize)! !!AISparseRowMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.964-04:00'!doSparseWithIndices: trinaryBlock		rows		doWithIndex:			[:vector :row | 			vector				doSparseWithIndex:					[:each :column | trinaryBlock value: each value: row value: column]].	^self! !!AISparseRowMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.964-04:00'!isZeroAt: row and: column		^(rows at: row) isZeroAt: column! !!AISparseRowMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.964-04:00'!sparseSize		^rows		inject: 0		into: [:sum :each | sum + each sparseSize]! !!AISparseRowMatrix methodsFor: 'printing' stamp: '2025-08-06T15:19:14.967-04:00'!storeOn: stream		| text |	text := String new writeStream.	self storeSparseTextOn: text.	stream		print: self class;		space;		nextPutAll: #readFromSparseText:;		space;		print:				(text contents						replaceAll: Character cr						with: Character space);		space;		nextPutAll: 'readStream'! !!AIDiagonalMatrix class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.969-04:00'!withDiagonal: vector		| newMatrix |	newMatrix := self new: vector size.	1		to: vector size		do:			[:index | 			newMatrix				at: index				and: index				put: (vector at: index)].	^newMatrix! !!AIDiagonalMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.971-04:00'!at: row and: column		^row = column		ifTrue: [partialColumns at: column]		ifFalse: [0]! !!AIDiagonalMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.971-04:00'!at: row and: column put: aNumber		^row = column		ifTrue: [partialColumns at: column put: aNumber]		ifFalse:			[aNumber isZero				ifFalse:					[self error: ('can not put <1p> off diagonal' expandMacrosWith: aNumber)].			aNumber]! !!AIDiagonalMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.972-04:00'!checkInvariant		^partialColumns isCollection	"(DiagonalMatrix new: 10) checkInvariant"! !!AIDiagonalMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.972-04:00'!initializeRows: m columns: n		m = n ifFalse: [Array new noMatchError].	partialColumns := Array new: m.	^self! !!AISymetricMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.974-04:00'!at: row and: column		^row < column		ifTrue: [(partialColumns at: column) at: row]		ifFalse: [(partialColumns at: row) at: column]! !!AISymetricMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.975-04:00'!at: row and: column put: aNumber		^row < column		ifTrue: [(partialColumns at: column) at: row put: aNumber]		ifFalse: [(partialColumns at: row) at: column put: aNumber]! !!AISymetricMatrix methodsFor: 'private' stamp: '2025-08-06T15:19:14.979-04:00'!checkInvariant		^partialColumns isCollection		and:			[(partialColumns				allSatisfy: [:vector | vector isKindOf: self vectorSpecies])				and:					[(1 to: self columnSize)						allSatisfy: [:index | (partialColumns at: index) size = index]]]	"(SymetricMatrix new: 10) checkInvariant"! !!AISymetricMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.98-04:00'!columnSize		^partialColumns size! !!AISymetricMatrix methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.983-04:00'!initializeRows: m columns: n		m = n ifFalse: [Array new noMatchError].	partialColumns := Array new: n.	1		to: n		do:			[:index | 			partialColumns				at: index				put: (self vectorSpecies new: index)]! !!AISymetricMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.984-04:00'!isSquare	"Each symatric matrix is square."		^true! !!AISymetricMatrix methodsFor: 'testing' stamp: '2025-08-06T15:19:14.984-04:00'!isSymetric	"Each symetric matrix is symatric."		^true! !!AISymetricMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.985-04:00'!partialColumns	^ partialColumns! !!AISymetricMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.985-04:00'!partialColumns: anObject	partialColumns := anObject! !!AISymetricMatrix methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.986-04:00'!rowSize		^partialColumns size	"since we are square"! !!AISymetricMatrix methodsFor: 'matrix functions' stamp: '2025-08-06T15:19:14.987-04:00'!transposed	"Answer self, since symatric matrices are invariant under transposition."		^self! !!AISymetricMatrix methodsFor: 'enumerating' stamp: '2025-08-06T15:19:14.988-04:00'!upperTriangleDoWithIndices: aBlock		1		to: self columnSize		do:			[:column | 			1				to: column				do:					[:row | 					aBlock						value: (self at: row and: column)						value: row						value: column]]! !!AIMedianAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.988-04:00'!new		^self basicNew initialize! !!AIMedianAccumulator class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:14.991-04:00'!withAll: aCollection		^(self new)		addAll: aCollection;		yourself! !!AIMedianAccumulator methodsFor: 'accumulating' stamp: '2025-08-06T15:19:14.992-04:00'!add: value		values add: value! !!AIMedianAccumulator methodsFor: 'accumulating' stamp: '2025-08-06T15:19:14.993-04:00'!addAll: aCollection		values addAll: aCollection! !!AIMedianAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.996-04:00'!bottom		^values last! !!AIMedianAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:14.998-04:00'!firstQuartil		^values at: (values size / 4) asInteger! !!AIMedianAccumulator methodsFor: 'initialize-release' stamp: '2025-08-06T15:19:14.998-04:00'!initialize		values := SortedCollection new! !!AIMedianAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:15-04:00'!median		^values at: (values size / 2) asInteger! !!AIMedianAccumulator methodsFor: 'printing' stamp: '2025-08-06T15:19:15.001-04:00'!printOn: aStream		aStream		nextPutAll: 'Median = ';		print: self median;		space;		nextPut: $(;		print: self top;		nextPut: $;;		space;		print: self firstQuartil;		nextPut: $;;		space;		print: self median;		nextPut: $;;		space;		print: self thirdQuartil;		nextPut: $;;		space;		print: self bottom;		nextPut: $)! !!AIMedianAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:15.002-04:00'!thirdQuartil		^values at: (values size / 4 * 3) asInteger! !!AIMedianAccumulator methodsFor: 'accessing' stamp: '2025-08-06T15:19:15.003-04:00'!top		^values first! !!AIMedianAccumulator methodsFor: 'accumulating' stamp: '2025-08-06T15:19:15.004-04:00'!value: value		values add: value! !!AIGlobalWeighting methodsFor: 'weighting' stamp: '2025-08-06T15:19:15.005-04:00'!documentFrequency: aVector		^aVector sparseSize! !!AIGlobalWeighting methodsFor: 'weighting' stamp: '2025-08-06T15:19:15.005-04:00'!forTerm: aVector		^self subclassResponsibility! !!AIGlobalWeighting methodsFor: 'weighting' stamp: '2025-08-06T15:19:15.007-04:00'!globalFrequency: aVector		^aVector sum! !!AILocalWeighting methodsFor: 'weighting' stamp: '2025-08-06T15:19:15.007-04:00'!forValue: value		^self subclassResponsibility! !!AIWeighting methodsFor: 'accessing' stamp: '2025-08-06T15:19:15.007-04:00'!abbreviation		^self subclassResponsibility! !!AIUnlimited class methodsFor: 'testing' stamp: '2025-08-06T15:19:15.008-04:00'!negative	^Negative ifNil: [Negative := super new initializeWith: false]! !!AIUnlimited class methodsFor: 'instance creation' stamp: '2025-08-06T15:19:15.009-04:00'!new	^self positive! !!AIUnlimited class methodsFor: 'testing' stamp: '2025-08-06T15:19:15.012-04:00'!positive	^Positive ifNil: [Positive := super new initializeWith: true ]! !!AIUnlimited methodsFor: 'comparing' stamp: '2025-08-06T15:19:15.013-04:00'!< aMagnitude	"Any number is larger than Unlimited negative, except Unlimited negative itself."	^(positive not) and: [ self ~~ aMagnitude ]! !!AIUnlimited methodsFor: 'comparing' stamp: '2025-08-06T15:19:15.014-04:00'!= aMagnitude		^self == aMagnitude! !!AIUnlimited methodsFor: 'converting' stamp: '2025-08-06T15:19:15.017-04:00'!adaptToNumber: rcvr andSend: selector	selector = #<		ifTrue: [ self positive				ifTrue: [ ^ true ]				ifFalse: [ ^ false ] ].	selector = #>		ifTrue: [ self positive				ifTrue: [ ^ false ]				ifFalse: [ ^ true ] ]! !!AIUnlimited methodsFor: 'comparing' stamp: '2025-08-06T15:19:15.018-04:00'!hash	^positive 		ifTrue: [ 16r3FFF ]		ifFalse: [ 16rBFFF ]! !!AIUnlimited methodsFor: 'initialization' stamp: '2025-08-06T15:19:15.02-04:00'!initializeWith: isPositive	positive := isPositive.	^self! !!AIUnlimited methodsFor: 'arithmetic' stamp: '2025-08-06T15:19:15.021-04:00'!negated	^self positive 		ifTrue: [ self class negative ] 		ifFalse: [ self class positive ]! !!AIUnlimited methodsFor: 'testing' stamp: '2025-08-06T15:19:15.022-04:00'!negative	^positive not! !!AIUnlimited methodsFor: 'accessing' stamp: '2025-08-06T15:19:15.023-04:00'!positive	^positive! !!AIUnlimited methodsFor: 'printing' stamp: '2025-08-06T15:19:15.024-04:00'!printOn: aStream	" Private - See superimplementor's comment "	super printOn: aStream.	aStream 		<< $(;		<< (self positive ifTrue: [ $+ ] ifFalse: [ $- ]);		<< $).! !"AI-MooseLinearAlgebra"!!AIAccumulatorTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIBooleanVectorTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMatrixCoercionTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIMatrixTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIArrayMatrixTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIColumnMatrixTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIRowMatrixTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AISparseColumnMatrixTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AINameMappingTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIUnlimitedTest commentStamp: '' prior: 0!A MLUnlimitedTest is a test class for testing the behavior of MLUnlimited!!AIVectorTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIArrayVectorTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIFloatVectorTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AISparseVectorTest commentStamp: '' prior: 0!Copyright (c), 2004-2007 Adrian Kuhn. This class is part of Hapax. Hapax is distributed under BSD License, see package comment.!!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.721-04:00'!testAverage	| a |	a := AIAccumulator sum.	a accumulate: 10.	self assert: a average equals: 10.	a accumulate: 1.	self assert: a average equals: 11 / 2.	a accumulate: 100.	self assert: a average equals: 111 / 3! !!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.728-04:00'!testCustomBlock	| a |	a := AIAccumulator value: 0 using: [ :current :new | current max: new size ].	a accumulate: 'ab'.	self assert: a value equals: 2.	a accumulate: 'a'.	self assert: a value equals: 2.	a accumulate: 'abc'.	self assert: a value equals: 3! !!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.73-04:00'!testEnumerate	| a |	a := AIAccumulator minimum.	a enumerate: #(10 1 100).	self assert: a value equals: 1! !!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.732-04:00'!testEnumerateWithIndex	| a |	a := AIAccumulator minimum.	a enumerateWithIndex: #(10 1 100).	self assert: a index equals: 2.	self assert: a value equals: 1! !!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.734-04:00'!testIfTruePut	| a |	a := AIAccumulator maximum.	a accumulate: 10 withIndex: 'first'.	self assert: a index equals: 'first'.	self assert: a value equals: 10.	a accumulate: 1 withIndex: 'second'.	self assert: a index equals: 'first'.	self assert: a value equals: 10.	a accumulate: 100 withIndex: 'third'.	self assert: a index equals: 'third'.	self assert: a value equals: 100! !!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.735-04:00'!testMaximum	| a |	a := AIAccumulator maximum.	a accumulate: 10.	self assert: a value equals: 10.	a accumulate: 1.	self assert: a value equals: 10.	a accumulate: 100.	self assert: a value equals: 100! !!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.736-04:00'!testMinimum	| a |	a := AIAccumulator minimum.	a accumulate: 10.	self assert: a value equals: 10.	a accumulate: 1.	self assert: a value equals: 1.	a accumulate: 100.	self assert: a value equals: 1! !!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.737-04:00'!testSquaredSum	| a |	a := AIAccumulator squaredSum.	a enumerate: #(1 2 3 4 5 6 7 8 9 10).	self assert: a value equals: 385! !!AIAccumulatorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.737-04:00'!testSum	| a |	a := AIAccumulator sum.	a enumerate: #(1 2 3 4 5 6 7 8 9 10).	self assert: a value equals: 55! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.738-04:00'!testAccessingLarge	v := AIBooleanVector new: 100.	v at: 83 put: true.	self assert: v size equals: 100.	self assert: (v at: 82) not.	self assert: (v at: 83).	self assert: (v at: 84) not.	v at: 83 put: false.	self assert: (v allSatisfy: #not)! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.739-04:00'!testAccessingSmall	v := AIBooleanVector new: 5.	v at: 3 put: true.	self assert: v size equals: 5.	self assert: (v at: 2) not.	self assert: (v at: 3).	self assert: (v at: 4) not.	v at: 3 put: false.	self assert: (v allSatisfy: #not)! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.741-04:00'!testAnd	| w vw |	v := AIBooleanVector withAll: #(false false true true false false true true).	w := AIBooleanVector withAll: #(false true false true true false true false).	vw := v & w.	self assert: vw size equals: 8.	self assert: vw asArray equals: #(false false false true false false true false)! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.741-04:00'!testNew	v := AIBooleanVector new.	self assert: v size equals: 0! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.743-04:00'!testNewLarge	v := AIBooleanVector new: 100.	self assert: v size equals: 100.	self assert: (v allSatisfy: #not)! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.743-04:00'!testNewSmall	v := AIBooleanVector new: 5.	self assert: v size equals: 5.	self assert: (v allSatisfy: #not)! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.744-04:00'!testNewWithAll	v := AIBooleanVector new: 100 withAll: true.	self assert: v size equals: 100.	self assert: (v allSatisfy: #yourself)! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.744-04:00'!testNot	v := AIBooleanVector withAll: #(false false true true false false true true).	self assert: v not size equals: 8.	self assert: v not asArray equals: #(true true false false true true false false)! !!AIBooleanVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.744-04:00'!testOr	| w vw |	v := AIBooleanVector withAll: #(false false true true false false true true).	w := AIBooleanVector withAll: #(false true false true true false true false).	vw := v | w.	self assert: vw size equals: 8.	self assert: vw asArray equals: #(false true true true true false true true)! !!AIDiagonalMatrixTest methodsFor: 'tests' stamp: '2025-08-06T15:19:16.745-04:00'!testAccessors	| m |	m := AIDiagonalMatrix withDiagonal: #(3 4 5).		self assert: (m at: 1 and: 1) equals: 3.	self assert: (m at: 2 and: 1) equals: 0.	self assert: (m at: 3 and: 3) equals: 5.   ! !!AIDiagonalMatrixTest methodsFor: 'tests' stamp: '2025-08-06T15:19:16.746-04:00'!testDimension	| m |	m := AIDiagonalMatrix new: 5.	self assert: m rowSize equals: 5.	self assert: m columnSize equals: 5.! !!AIMatrixCoercionTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.746-04:00'!testFloat		| m n |	m := AIColumnMatrix		new: 4 @ 3		withAll: 2.	n := 2.0.	m + n.	n + m.	m - n.	n - m.	m * n.	n * m.	m / n.	n / m! !!AIMatrixCoercionTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.748-04:00'!testFraction		| m n |	m := AIColumnMatrix		new: 4 @ 3		withAll: 2.	n := 1 / 2.	m + n.	n + m.	m - n.	n - m.	m * n.	n * m.	m / n.	n / m! !!AIMatrixCoercionTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.749-04:00'!testInteger		| m n |	m := AIColumnMatrix		new: 4 @ 3		withAll: 2.	n := 2.	m + n.	n + m.	m - n.	n - m.	m * n.	n * m.	m / n.	n / m! !!AIMatrixCoercionTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.75-04:00'!testLargeInteger		| m n |	m := AIColumnMatrix		new: 4 @ 3		withAll: 2.	n := 2000000000000.	m + n.	n + m.	m - n.	n - m.	m * n.	n * m.	m / n.	n / m! !!AIMatrixCoercionTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.751-04:00'!testPoint		| m n |	m := AIColumnMatrix		new: 4 @ 3		withAll: 2.	n := 2 @ 2.	m + n.	n + m.	m - n.	n - m.	m * n.	n * m.	m / n.	n / m! !!AIArrayMatrixTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.751-04:00'!matrixClass		^AIArrayMatrix! !!AIArrayMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.754-04:00'!testDeterminant	| matrix |	matrix := AIArrayMatrix rows: 3 columns: 3.	self assertBlock: [ matrix determinant ] raises: AssertionFailure.	matrix := AIArrayMatrix rows: 2 columns: 2 withAll: #(3 6 9 2).	self assert: matrix determinant equals: -48! !!AIColumnMatrixTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.755-04:00'!matrixClass		^AIColumnMatrix! !!AIColumnMatrixTest methodsFor: 'tests' stamp: '2025-08-06T15:19:16.756-04:00'!testColumns		|m|	m := AIColumnMatrix new columns: #( #(0 1 2) #(2 3 4)).	self assert: (m at: 1 and: 2) equals: 2.	self assert: (m at: 3 and: 1)  equals: 2.! !!AIColumnMatrixTest methodsFor: 'tests' stamp: '2025-08-06T15:19:16.757-04:00'!testinitialization 		|m|	m := AIColumnMatrix  new initializeRows: 3 columns: 4.	self assert: m rowSize equals: 3.	self assert: m columnSize  equals: 4.! !!AIMatrixTest class methodsFor: 'testing' stamp: '2025-08-06T15:19:16.757-04:00'!isAbstract		^self name = #AIMatrixTest! !!AIMatrixTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.758-04:00'!matrixClass	"comment stating purpose of message"		^self subclassResponsibility! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.759-04:00'!testAccessors	"comment stating purpose of message"	| m |	m := self matrixClass new: 2 @ 3.	m at: 1 and: 2 put: 12.	m at: 2 and: 1 put: 21.	self assert: (m at: 1 and: 2) equals: 12.	self assert: (m at: 2 and: 1) equals: 21.	m at: 1 and: 3 put: 13.	self assert: (m at: 1 and: 3) equals: 13.	self assert: (m atPoint: 1 @ 3) equals: 13! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.761-04:00'!testAddWithMatrix	"comment stating purpose of message"	| m n mn |	m := self matrixClass withAll: #(#(1 2) #(3 4) #(5 6)).	n := self matrixClass withAll: #(#(10 20) #(30 40) #(50 60)).	mn := self matrixClass withAll: #(#(11 22) #(33 44) #(55 66)).	self assert: m + n equals: mn.	m += n.	self assert: m equals: mn.	self assert: n equals: (self matrixClass withAll: #(#(10 20) #(30 40) #(50 60)))! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.762-04:00'!testAddWithNumber	"comment stating purpose of message"	| m m10 |	m := self matrixClass withAll: #(#(1 2) #(3 4) #(5 6)).	m10 := self matrixClass withAll: #(#(11 12) #(13 14) #(15 16)).	self assert: m + 10 equals: m10.	self assert: 10 + m equals: m10.	"no longer Double in Pharo"	"self assert: m + 10.0d = m10."	"self assert: 10.0d + m = m10."	m += 10.	self assert: m equals: m10! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.764-04:00'!testArithmeticUnity	| a |	a := self matrixClass new: 2 withAll: #(1 2 3 4).	self assert: AIMatrix unity * a equals: a.	self assert: (AIMatrix unity + a) asArray equals: #(2 3 4 5).	self assert: AIMatrix unity * AIMatrix unity equals: AIMatrix unity.	self assert: (AIMatrix unity + AIMatrix unity) asNumber equals: 2.	self assert: AIMatrix unity + AIMatrix zero equals: AIMatrix unity! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.765-04:00'!testArithmeticZero	| a |	a := self matrixClass new: 2 withAll: #(1 2 3 4).	self assert: AIMatrix zero * a equals: AIMatrix zero.	self assert: AIMatrix zero + a equals: a.	self assert: AIMatrix zero * AIMatrix zero equals: AIMatrix zero.	self assert: AIMatrix zero + AIMatrix zero equals: AIMatrix zero.	self assert: AIMatrix unity * AIMatrix zero equals: AIMatrix zero! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.766-04:00'!testDimension	"comment stating purpose of message"	| m |	m := self matrixClass new: 3 @ 7.	self assert: m rowSize equals: 3.	self assert: m columnSize equals: 7.	self assert: m dimension equals: 3 @ 7! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.767-04:00'!testIsZero	"comment stating purpose of message"		| m |	m := self matrixClass withAll: #(#(1 2) #(3 4) #(5 6)).	self assert: m isZero not! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.767-04:00'!testMatrixMultiplicationDimension	"comment stating purpose of message"	| a b |	a := self matrixClass withAll: #(#(1 2 3) #(4 5 6)).	b := self matrixClass withAll: #(#(6 -1) #(3 2) #(0 -3)).	self assert: (a *~ b) dimension equals: 2 @ 2.	self assert: (b *~ a) dimension equals: 3 @ 3.	self assert: (a transposed *~ a) dimension equals: 3 @ 3.	self assert: (b transposed *~ b) dimension equals: 2 @ 2! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.769-04:00'!testMatrixMultiplicationValues	"comment stating purpose of message"	| a b |	a := self matrixClass withAll: #(#(1 2 3) #(4 5 6)).	b := self matrixClass withAll: #(#(6 -1) #(3 2) #(0 -3)).	self assert: a *~ b equals: (self matrixClass withAll: #(#(12 -6) #(39 -12))).	self assert: b *~ a equals: (self matrixClass withAll: #(#(2 7 12) #(11 16 21) #(-12 -15 -18))).	self assert: a transposed *~ a equals: (self matrixClass withAll: #(#(17 22 27) #(22 29 36) #(27 36 45))).	self assert: b transposed *~ b equals: (self matrixClass withAll: #(#(45 0) #(0 14)))! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.77-04:00'!testMultWithMatrix	"comment stating purpose of message"	| m n mn |	m := self matrixClass withAll: #(#(1 2) #(3 4) #(5 6)).	n := self matrixClass withAll: #(#(10 20) #(30 40) #(50 60)).	mn := self matrixClass withAll: #(#(10 40) #(90 160) #(250 360)).	self assert: m * n equals: mn.	m *= n.	self assert: m equals: mn.	self assert: n equals: (self matrixClass withAll: #(#(10 20) #(30 40) #(50 60)))! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.771-04:00'!testMultWithNumber	"comment stating purpose of message"	| m m10 |	m := self matrixClass withAll: #(#(1 2) #(3 4) #(5 6)).	m10 := self matrixClass withAll: #(#(10 20) #(30 40) #(50 60)).	self assert: m * 10 equals: m10.	self assert: 10 * m equals: m10.	"no longer Double in Pharo"	"self assert: m * 10.0d = m10.	self assert: 10.0d * m = m10."	m *= 10.	self assert: m equals: m10! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.772-04:00'!testReadDenseTextFrom	| matrix text stream |	matrix := AIArrayMatrix withAll: #(#(2.3 0 4.2) #(0 1.3 2.2) #(3.8 0 0.5) #(0 0 0)).	text := '4 3\2.3 0 4.2\0 1.3 2.2\3.8 0 0.5\0 0 0\' withCRs.	stream := ReadStream on: text.	self assert: matrix equals: (self matrixClass readFromDenseText: stream)! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.773-04:00'!testReadSparseTextFrom	| matrix text stream |	matrix := AIArrayMatrix withAll: #(#(2.3 0 4.2) #(0 1.3 2.2) #(3.8 0 0.5) #(0 0 0)).	matrix := matrix transposed.	text := '4 3 6\2\0 2.3\2 3.8\1\1 1.3\3\0 4.2\1 2.2\2 0.5\' withCRs.	stream := ReadStream on: text.	self assert: matrix equals: (self matrixClass readFromSparseText: stream)! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.776-04:00'!testRowColumnSize	"comment stating purpose of message"	| m |	m := self matrixClass rows: 3 columns: 7.	self assert: m rowSize equals: 3.	self assert: m columnSize equals: 7.	self assert: m dimension equals: 3 @ 7! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.776-04:00'!testStoreDenseTextOn	| matrix text stream |	matrix := self matrixClass withAll: #(#(2.3 0 4.2) #(0 1.3 2.2) #(3.8 0 0.5) #(0 0 0)).	text := '4 3\2.3 0 4.2\0 1.3 2.2\3.8 0 0.5\0 0 0\' withCRs.	stream := WriteStream on: String new.	matrix storeDenseTextOn: stream.	self assert: stream contents equals: text! !!AIMatrixTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.783-04:00'!testStoreSparseTextOn	| matrix text stream |	matrix := self matrixClass withAll: #(#(2.3 0 4.2) #(0 1.3 2.2) #(3.8 0 0.5) #(0 0 0)).	matrix := matrix transposed.	text := '4 3 6\2\0 2.3\2 3.8\1\1 1.3\3\0 4.2\1 2.2\2 0.5\' withCRs.	stream := WriteStream on: String new.	matrix storeSparseTextOn: stream.	self assert: stream contents equals: text! !!AIRowMatrixTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.784-04:00'!matrixClass		^AIRowMatrix! !!AISparseColumnMatrixTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.784-04:00'!matrixClass		^AISparseColumnMatrix! !!AINameMappingTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.786-04:00'!testAddDuplicate		| m |	m := AINameMapping new addAll: #(#a #b #c #d); yourself.	self		should: [m add: #a]		raise: Error! !!AINameMappingTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.787-04:00'!testNames		| m |	m := AINameMapping new addAll: #(#a #b #c #d); yourself.	self assert: m asArray equals: #(1 2 3 4).	self assert: m names asArray equals: #(#a #b #c #d)! !!AIUnlimitedTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.788-04:00'!testEqualsSign	self assert: AIUnlimited positive equals: AIUnlimited positive.	self assert: AIUnlimited negative equals: AIUnlimited negative! !!AIUnlimitedTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.789-04:00'!testNegated	self assert: AIUnlimited positive negated equals: AIUnlimited negative.	self assert: AIUnlimited negative negated equals: AIUnlimited positive.! !!AIUnlimitedTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.79-04:00'!testNegative	" Every unlimited negative is not bigger than any magnitude "	self assert: AIUnlimited negative > 0 equals: false.	self assert: AIUnlimited negative > 1 equals: false.	self assert: AIUnlimited negative > 1 negated equals: false.	" Every unlimited negative is smaller than any magnitude "	self assert: AIUnlimited negative < 0 equals: true.	self assert: AIUnlimited negative < 1 equals: true.	self assert: AIUnlimited negative < 1 negated equals: true.! !!AIUnlimitedTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.79-04:00'!testPositive	" Every unlimited positive is greater than any magnitude "	self assert: AIUnlimited positive > 0 equals: true.	self assert: AIUnlimited positive > 1 equals: true.	self assert: AIUnlimited positive > 1 negated equals: true.	" Every unlimited positive is not smaller than any magnitude "	self assert: AIUnlimited positive < 0 equals: false.	self assert: AIUnlimited positive < 1 equals: false.	self assert: AIUnlimited positive < 1 negated equals: false.! !!AIArrayVectorTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.79-04:00'!vectorClass		^AIArrayVector! !!AIFloatVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.792-04:00'!testQuotient	"the notorious equality problem with floats"	self assert: true! !!AIFloatVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.793-04:00'!testStoreDenseTextOn	"when comparing text 0 is not 0.0"	self assert: true! !!AIFloatVectorTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.793-04:00'!vectorClass		^AIFloatVector! !!AISparseVectorTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.793-04:00'!vectorClass		^AISparseVector! !!AIVectorTest class methodsFor: 'testing' stamp: '2025-08-06T15:19:16.793-04:00'!isAbstract		^self name = #AIVectorTest! !!AIVectorTest methodsFor: 'running' stamp: '2025-08-06T15:19:16.794-04:00'!setUp	"comment stating purpose of message"	super setUp.	v := self vectorClass withAll: (1 to: 10).	w := self vectorClass new: 10 withAll: -5! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.794-04:00'!testAccessors	"comment stating purpose of message"		v := self vectorClass new: 1.	v at: 1 put: 77.	self deny: (v at: 1) = 0. "For Pharo 6compatibility because there is no #deny:equals:"	self deny: (v at: 1) isNil! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.795-04:00'!testAccessors2	"comment stating purpose of message"	v := self vectorClass new: 3.	v at: 1 put: 77.	v at: 2 put: 23.	v at: 3 put: 42.	self assert: (v at: 1) equals: 77.	self assert: (v at: 2) equals: 23.	self assert: (v at: 3) equals: 42! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.795-04:00'!testAccessors3	"comment stating purpose of message"	v := self vectorClass withAll: #(4 5 7).	v at: 1 put: 77.	v at: 2 put: 23.	v at: 3 put: 42.	self assert: (v at: 1) equals: 77.	self assert: (v at: 2) equals: 23.	self assert: (v at: 3) equals: 42! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.796-04:00'!testAccessors4	"comment stating purpose of message"	v := self vectorClass withAll: #(4 5 7).	v at: 1 put: 0.	v at: 2 put: 0.	v at: 3 put: 0.	self assert: (v at: 1) equals: 0.	self assert: (v at: 2) equals: 0.	self assert: (v at: 3) equals: 0! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.798-04:00'!testDifference	"comment stating purpose of message"	self assert: v - 2 equals: (self vectorClass withAll: #(-1 0 1 2 3 4 5 6 7 8)).	self assert: 2 - v equals: (self vectorClass withAll: #(1 0 -1 -2 -3 -4 -5 -6 -7 -8)).	self assert: v - 2 equals: (2 - v) negated.	"no longer double in pharo"	"self assert: v - 2 = (v - 2.0d)."	self assert: v - 2 equals: v - 2.0.	v -= 2.	self assert: v equals: (self vectorClass withAll: #(-1 0 1 2 3 4 5 6 7 8))! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.799-04:00'!testDotProduct	"comment stating purpose of message"	v := self vectorClass withAll: #(1 2 3).	w := self vectorClass withAll: #(5 -11 7).	self assert: (v dotProduct: w) equals: 1 * 5 + (2 * -11) + (3 * 7).	self assert: (v dotProduct: v) equals: 1 * 1 + (2 * 2) + (3 * 3).	self assert: (w dotProduct: w) equals: 5 * 5 + (11 * 11) + (7 * 7)! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.799-04:00'!testLength	"comment stating purpose of message"	v := self vectorClass withAll: #(1 2 3).	w := self vectorClass withAll: #(5 -11 7).	self assert: v length equals: (1 * 1 + (2 * 2) + (3 * 3)) sqrt.	self assert: w length equals: (5 * 5 + (11 * 11) + (7 * 7)) sqrt! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.801-04:00'!testNonZeroSize	v := self vectorClass new: 100 withAll: 0.	self assert: v sparseSize equals: 0.	v at: 23 put: 1.	self assert: v sparseSize equals: 1.	v at: 23 put: 0.	self assert: v sparseSize equals: 0.	v at: 17 put: 1.	v at: 27 put: 2.	v at: 77 put: 3.	self assert: v sparseSize equals: 3.	v at: 27 put: 4.	self assert: v sparseSize equals: 3.	v at: 17 put: 0.	self assert: v sparseSize equals: 2.	v at: 43 put: 0.	self assert: v sparseSize equals: 2! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.802-04:00'!testProduct	"comment stating purpose of message"	self assert: v * 2 equals: (self vectorClass withAll: #(2 4 6 8 10 12 14 16 18 20)).	self assert: v * 2 equals: 2 * v.	"no more double in Pharo"	"self assert: v * 2 = (v * 2.0d)."	self assert: v * 2 equals: v * 2.0.	v *= 2.	self assert: v equals: (self vectorClass withAll: #(2 4 6 8 10 12 14 16 18 20))! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.804-04:00'!testProductVector	"comment stating purpose of message"	self assert: v * w equals: (self vectorClass withAll: #(-5 -10 -15 -20 -25 -30 -35 -40 -45 -50)).	self assert: v * w equals: w * v! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.805-04:00'!testQuotient	"comment stating purpose of message"	self assert: v / 2 equals: (self vectorClass withAll: #(0.5 1 1.5 2 2.5 3 3.5 4 4.5 5)).	self assert: (2 / v) first equals: 2.	self assert: v / 2 equals: (2 / v) reciprocal.	"no longer double in pharo"	"self assert: v / 2 = (v / 2.0d)."	self assert: v / 2 equals: v / 2.0.	v /= 2.	self assert: v equals: (self vectorClass withAll: #(0.5 1 1.5 2 2.5 3 3.5 4 4.5 5))! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.806-04:00'!testReadDenseTextFrom	| vector text stream |	vector := AIArrayVector withAll: #(2.3 0 4.2 0 1.3 2.2 3.8 0 0.5 0 0 0).	text := '12\2.3 0 4.2 0 1.3 2.2 3.8 0 0.5 0 0 0\' withCRs.	stream := ReadStream on: text.	self assert: vector equals: (self vectorClass readFromDenseText: stream)! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.807-04:00'!testStoreDenseTextOn	| vector text stream |	vector := self vectorClass withAll: #(2.3 0 4.2 0 1.3 2.2 3.8 0 0.5 0 0 0).	text := '12\2.3 0 4.2 0 1.3 2.2 3.8 0 0.5 0 0 0\' withCRs.	stream := WriteStream on: String new.	vector storeDenseTextOn: stream.	self assert: stream contents equals: text! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.809-04:00'!testSum	"comment stating purpose of message"	self assert: v + 2 equals: (self vectorClass withAll: #(3 4 5 6 7 8 9 10 11 12)).	self assert: v + 2 equals: 2 + v.	"no longer double in pharo"	"self assert: v + 2 = (v + 2.0d)."	self assert: v + 2 equals: v + 2.0.	v += 2.	self assert: v equals: (self vectorClass withAll: #(3 4 5 6 7 8 9 10 11 12))! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.809-04:00'!testSumVector	"comment stating purpose of message"	self assert: v + w equals: (self vectorClass withAll: #(-4 -3 -2 -1 0 1 2 3 4 5)).	self assert: v + w equals: w + v! !!AIVectorTest methodsFor: 'test' stamp: '2025-08-06T15:19:16.81-04:00'!testUnitVector	"comment stating purpose of message"	"no longer double in pharo"	"self assert: v unitVector length asFloat = 1.0d asFloat.	self assert: w unitVector length asFloat = 1.0d asFloat"	self assert: v unitVector length asFloat equals: 1.0	"here,something special in pharo. Those two floats have the same values but the egality test return false "	"self assert: (tmp := w unitVector length asFloat) = 1.0."! !!AIVectorTest methodsFor: 'fixture' stamp: '2025-08-06T15:19:16.812-04:00'!vectorClass		self subclassResponsibility! !"AI-MooseLinearAlgebra-Tests"!----QUIT----2025-08-07T02:39:55.443-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 86485!----QUIT----2025-08-07T02:39:55.46-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 227542!----SNAPSHOT----2025-08-08T17:29:07.721-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 227660!----SNAPSHOT----2025-08-08T17:29:07.739-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 227778!!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-08T17:29:29.503-04:00'!checkForSquareMatrix	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	| rows columns augmentedMatrix identity invertedMatrix Matrix|	"Check if the matrix is square."	rows = columns ifFalse: [		self error: 'Matrix must be square to be invertible.' ].	"Create an augmented matrix by combining the original matrix	   with an identity matrix of the same size."	identity := Matrix identity: rows.	augmentedMatrix := (1 to: rows) collect: [ :i |		(self elements at: i), (identity elements at: i) ].! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-08T17:31:26.631-04:00'!createAugmentedMatrix	"Create an augmented matrix by combining the original matrix	   with an identity matrix of the same size."	| augmentedMatrix identity invertedMatrix Matrix rows |	identity := Matrix identity: rows.	augmentedMatrix := (1 to: rows) collect: [ :i |		(self elements at: i), (identity elements at: i) ].! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-08T17:46:53.849-04:00'!methodSelectorAndArgumentNames	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| maxVal maxRow rows augmentedMatrix|	1 to: rows do: [ :pivotRow |		"Partial Pivoting: Find the row with the largest pivot element."				maxVal := (augmentedMatrix at: pivotRow) at: pivotRow.		maxRow := pivotRow.		pivotRow + 1 to: rows do: [ :currentRow |			((augmentedMatrix at: currentRow) at: pivotRow) abs > maxVal abs ifTrue: [				maxVal := (augmentedMatrix at: currentRow) at: pivotRow.				maxRow := currentRow.			]		]] .! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-08T20:31:06.4-04:00'!swapRowsIfHigherRowsFound	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| tempRow maxRow pivotRow augmentedMatrix|	maxRow ~= pivotRow ifTrue: [						tempRow := augmentedMatrix at: pivotRow.			augmentedMatrix at: pivotRow put: (augmentedMatrix at: maxRow).			augmentedMatrix at: maxRow put: tempRow.		].! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-10T12:18:39.624-04:00'!eleminateOtherEntries		|rows pivotRow augmentedMatrix  |			"Eliminate other entries in the pivot column."		1 to: rows do: [ :row |			row ~= pivotRow ifTrue: [				| factor |				factor := (augmentedMatrix at: row) at: pivotRow.				pivotRow to: rows*2 do: [ :col |					(augmentedMatrix at: row) at: col put: ((augmentedMatrix at: row) at: col) - (factor * ((augmentedMatrix at: pivotRow) at: col)).				].			]		].	! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-08-10T12:20:00.637-04:00'!performGaussianElimination"Perform Gaussian elimination to transform the left side into an identity matrix."|rows  maxVal maxRow augmentedMatrix pivotRow  |1 to: rows do: [ :pivotRow |		"Partial Pivoting: Find the row with the largest pivot element."		maxVal := (augmentedMatrix at: pivotRow) at: pivotRow.		maxRow := pivotRow.		pivotRow + 1 to: rows do: [ :currentRow |			((augmentedMatrix at: currentRow) at: pivotRow) abs > maxVal abs ifTrue: [				maxVal := (augmentedMatrix at: currentRow) at: pivotRow.				maxRow := currentRow.			]		]	].! !----SNAPSHOT----2025-08-10T13:40:23.955-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 227901!----SNAPSHOT----2025-08-10T13:40:23.977-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 231317!!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-08-10T13:42:02.577-04:00'!partialPivoting	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"| maxVal maxRow rows augmentedMatrix|	1 to: rows do: [ :pivotRow |		"Partial Pivoting: Find the row with the largest pivot element."				maxVal := (augmentedMatrix at: pivotRow) at: pivotRow.		maxRow := pivotRow.		pivotRow + 1 to: rows do: [ :currentRow |			((augmentedMatrix at: currentRow) at: pivotRow) abs > maxVal abs ifTrue: [				maxVal := (augmentedMatrix at: currentRow) at: pivotRow.				maxRow := currentRow.			]		]] .! !BeMatrixInversion removeSelector: #methodSelectorAndArgumentNames!BeMatrixInversion removeSelector: #multiplyInverse!!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-08-10T14:48:13.901-04:00' prior: 456205!checkForSquareMatrix	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	| rows columns identity augmentedMatrix Matrix|	"Check if the matrix is square."	rows = columns ifFalse: [		self error: 'Matrix must be square to be invertible.' ].	"Create an augmented matrix by combining the original matrix	   with an identity matrix of the same size."	identity := Matrix identity: rows.	augmentedMatrix := (1 to: rows) collect: [ :i |		(self elements at: i), (identity elements at: i) ].! !----SNAPSHOT----2025-08-10T15:33:51.131-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 231440!----SNAPSHOT----2025-08-10T15:33:51.153-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 232984!----SNAPSHOT----2025-08-11T00:40:39.846-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 233107!----SNAPSHOT----2025-08-11T00:40:39.863-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 233230!----SNAPSHOT----2025-08-11T01:55:29.102-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 233353!----SNAPSHOT----2025-08-11T01:55:29.118-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 233476!----SNAPSHOT----2025-08-11T01:55:29.589-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 233599!----SNAPSHOT----2025-08-11T01:55:29.6-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 233722!----SNAPSHOT----2025-08-11T01:55:29.804-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 233845!----SNAPSHOT----2025-08-11T01:55:29.818-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 233966!----SNAPSHOT----2025-08-11T02:00:59.284-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 234089!----SNAPSHOT----2025-08-11T02:00:59.298-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 234212!!BeRandom methodsFor: 'nil' stamp: '2025-08-11T02:01:05.64-04:00'!extractInverseMatrix	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|invertedMatrix rows augmentedMatrix aStream Matrix|	"4. Extract the inverse matrix from the right side of the augmented matrix."	invertedMatrix := (1 to: rows) collect: [ :i |		(augmentedMatrix at: i) copyFrom: rows + 1 to: rows * 2 ].	^ Matrix from: invertedMatrix."Matrix methodsFor: 'printing"	"Prints a nice representation of the matrix to a stream."	aStream nextPutAll: 'Matrix('; nextPutAll: self rows asString; nextPutAll: 'x'; nextPutAll: self cols asString; nextPutAll: ')'.	self elements do: [ :row |		aStream cr; nextPutAll: '  '; nextPutAll: row printString.	].	"Prints a nice representation of the matrix to a stream."	aStream nextPutAll: 'Matrix('; nextPutAll: self rows asString; nextPutAll: 'x'; nextPutAll: self cols asString; nextPutAll: ')'.	self elements do: [ :row |		aStream cr; nextPutAll: '  '; nextPutAll: row printString.	].! !BeMatrixInversion removeSelector: #innerBenchmarkLoop:!----QUIT----2025-08-11T03:06:15.481-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 234335!----QUIT----2025-08-11T03:06:15.498-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 235578!!BeRandom methodsFor: 'as yet unclassified' stamp: '2025-08-11T20:42:28.959-04:00' prior: 469053!extractInverseMatrix	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"|invertedMatrix rows augmentedMatrix aStream Matrix |	"4. Extract the inverse matrix from the right side of the augmented matrix."	invertedMatrix := (1 to: rows) collect: [ :i |		(augmentedMatrix at: i) copyFrom: rows + 1 to: rows * 2 ].	^ Matrix from: invertedMatrix."Matrix methodsFor: 'printing"aStream := WriteStream on: String new.	"Prints a nice representation of the matrix to a stream."	aStream nextPutAll: 'Matrix('; nextPutAll: self rows asString; nextPutAll: 'x'; nextPutAll: self cols asString; nextPutAll: ')'.	self elements do: [ :row |		aStream cr; nextPutAll: '  '; nextPutAll: row printString.	].	! !Benchmark removeSelector: #innerBenchmarkLoop:!----SNAPSHOT----2025-08-11T23:40:46.288-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 235697!----SNAPSHOT----2025-08-11T23:40:46.302-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 236718!----SNAPSHOT----2025-08-11T23:40:56.503-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 236841!----SNAPSHOT----2025-08-11T23:40:56.517-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 236964!----QUIT----2025-08-11T23:41:19.027-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237087!----QUIT----2025-08-11T23:41:19.043-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237210!----SNAPSHOT----2025-08-13T00:37:42.045-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237329!----SNAPSHOT----2025-08-13T00:37:42.06-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237448!----QUIT----2025-08-13T02:40:58.72-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237571!----QUIT----2025-08-13T02:40:58.734-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237693!----QUIT/NOSAVE----2025-08-13T15:04:33.472-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237811!----QUIT/NOSAVE----2025-08-13T15:04:33.516-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237811!----QUIT----2025-08-14T00:31:05.186-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 237811!----QUIT----2025-08-14T00:31:05.203-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 238182!----QUIT----2025-08-14T00:31:09.808-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 238420!----QUIT/NOSAVE----2025-08-15T16:33:20.46-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 238420!----QUIT/NOSAVE----2025-08-15T16:33:20.478-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 238420!----QUIT/NOSAVE----2025-08-15T17:01:48.412-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 238420!----QUIT/NOSAVE----2025-08-15T17:01:48.434-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 238420!----SNAPSHOT----2025-08-18T16:31:32.077-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 238420!----SNAPSHOT----2025-08-18T16:31:32.1-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 239042!!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-18T16:31:39.655-04:00'!innerBenchmarkLoop: iterations [	| result |	result := true.	1 to: iterations do: [ :i | result := result and: self multiplyInverse ].	^ result]! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-18T16:32:29.191-04:00'! multiplyInverse [ 	" calculate the inverse of sourceMatrix - non-destructively "	" then multiply that by sourceMatrix and return true if the result is close to an identity matrix, else false "		^ false]! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-18T23:47:47.617-04:00'!innerBenchmarkLoop: iterations [	| result |	result := true.	1 to: iterations do: [ :i | result := result and: self multiplyInverse ].	^ result]! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-18T23:49:24.618-04:00'!multiplyInverse [ 	" calculate the inverse of sourceMatrix - non-destructively "	" then multiply that by sourceMatrix and return true if the result is close to an identity matrix, else false "		^ true]! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-19T22:50:15.37-04:00'!innerBenchmarkLoop: iterations [	| result |	result := true.	1 to: iterations do: [ :i | result := result and: self multiplyInverse ].	^ result]! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-20T15:58:53.359-04:00'!innerBenchmarkLoop: iterations [	| result |	result := true.	1 to: iterations do: [ :i | result := result and: self multiplyInverse ].	^ result]! !BeMatrixInversion removeSelector: #checkForSquareMatrix!----SNAPSHOT----2025-08-20T16:41:19.842-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 239165!----SNAPSHOT----2025-08-20T16:41:19.889-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 240839!!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-20T16:42:17.302-04:00'!mutiplyInverse [ 				self halt createAugmentedMatrix .		^ true .	 ].! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-20T16:44:29.533-04:00'!extractInverseMatrix | invertedMatrix Matrix rows augmentedMatrix aStream|invertedMatrix := (1 to: rows) collect: [ :i |		(augmentedMatrix at: i) copyFrom: rows + 1 to: rows * 2 ].	^ Matrix from: invertedMatrix."Matrix methodsFor: 'printing'"	"Prints a nice representation of the matrix to a stream."	aStream nextPutAll: 'Matrix('; nextPutAll: self rows asString; nextPutAll: 'x'; nextPutAll: self cols asString; nextPutAll: ')'.	self elements do: [ :row |		aStream cr; nextPutAll: '  '; nextPutAll: row printString.	].! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-08-21T00:13:41.571-04:00'!eliminateOtherEntries		|rows pivotRow augmentedMatrix  |			"Eliminate other entries in the pivot column."		1 to: rows do: [ :row |			row ~= pivotRow ifTrue: [				| factor |				factor := (augmentedMatrix at: row) at: pivotRow.				pivotRow to: rows*2 do: [ :col |					(augmentedMatrix at: row) at: col put: ((augmentedMatrix at: row) at: col) - (factor * ((augmentedMatrix at: pivotRow) at: col)).				].			]		].	! !BeMatrixInversion removeSelector: #eleminateOtherEntries!!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-08-21T00:19:52.135-04:00' prior: 482327!mutiplyInverse [ 				self halt performGaussianElimination .		^ true .	 ].! !----SNAPSHOT----2025-08-21T00:24:33.072-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 240962!----SNAPSHOT----2025-08-21T00:24:33.087-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 242633!----SNAPSHOT----2025-08-21T00:41:36.059-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 242756!----SNAPSHOT----2025-08-21T00:41:36.077-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 242879!BeMatrixInversion removeSelector: #eliminateOtherEntries!----SNAPSHOT----2025-08-21T00:46:07.805-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 243002!----SNAPSHOT----2025-08-21T00:46:07.826-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 243184!----SNAPSHOT----2025-08-21T00:46:08.312-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 243307!----SNAPSHOT----2025-08-21T00:46:08.325-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 243430!----SNAPSHOT----2025-08-21T00:46:08.561-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 243553!----SNAPSHOT----2025-08-21T00:46:08.576-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 243676!!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-21T00:46:56.719-04:00'!createIdentityMatrix		| identityMatrix |	"Creates a new identity matrix of a given size."		identityMatrix := (1 to: size) collect: [ :i |		(1 to: size) collect: [ :j | (i = j) ifTrue: [ 1.0 ] ifFalse: [ 0.0 ] ] ].	^ self from: identityMatrix.! !----SNAPSHOT----2025-08-21T03:58:47.466-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 243799!----SNAPSHOT----2025-08-21T03:58:47.483-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 244252!----SNAPSHOT----2025-08-21T04:27:24.084-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 244375!----SNAPSHOT----2025-08-21T04:27:24.106-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 244498!!BeMatrixInversion methodsFor: 'nil' stamp: '2025-08-21T04:31:11.122-04:00'!createIdentityMatrix	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	| identity identityMatrix|	"Creates a new identity matrix of a given size."		identityMatrix := (1 to: size) collect: [ :i |		(1 to: size) collect: [ :j | (i = j) ifTrue: [ 1.0 ] ifFalse: [ 0.0 ] ] ].	^ self from: identityMatrix."at: aRow and: aCol put: aValue[	"Sets the element at the specified row and column to a new value."	(elements at: aRow) at: aCol put: aValue] "! !----SNAPSHOT----2025-08-21T04:31:31.922-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 244621!----SNAPSHOT----2025-08-21T04:31:31.942-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 245329!----QUIT----2025-08-21T04:31:57.504-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 245452!----QUIT----2025-08-21T04:31:57.519-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 245575!----SNAPSHOT----2025-08-21T04:36:21.492-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 245694!----SNAPSHOT----2025-08-21T04:36:21.505-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 245813!----SNAPSHOT----2025-08-21T04:46:14.07-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 245936!----SNAPSHOT----2025-08-21T04:46:14.086-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 246059!----QUIT----2025-08-21T04:46:32.296-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 246181!----QUIT----2025-08-21T04:46:32.312-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 246304!----SNAPSHOT----2025-08-26T20:59:24.999-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 246423!----SNAPSHOT----2025-08-26T20:59:25.016-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 246542!----QUIT----2025-08-26T20:59:30.209-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 246665!----QUIT----2025-08-26T20:59:30.227-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 246788!----QUIT----2025-08-27T15:17:43.842-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 246907!----QUIT----2025-08-27T15:17:43.869-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 247026!----QUIT/NOSAVE----2025-08-27T15:20:43.255-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 247145!----QUIT/NOSAVE----2025-08-27T15:20:43.299-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 247145!----QUIT/NOSAVE----2025-08-27T15:20:48.164-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 247145!----SNAPSHOT----2025-08-27T15:38:38.427-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 247145!----SNAPSHOT----2025-08-27T15:38:38.454-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 247642!----QUIT----2025-08-27T23:27:36.795-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 247765!----QUIT----2025-08-27T23:27:36.813-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 247888!----QUIT----2025-08-27T23:27:46.067-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248126!----QUIT----2025-08-27T23:27:59.849-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248245!----SNAPSHOT----2025-08-28T03:07:10.472-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248364!----QUIT----2025-08-28T03:07:20.632-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248364!----QUIT----2025-08-28T03:07:20.647-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248487!----QUIT----2025-08-29T03:25:33.259-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248606!----QUIT----2025-08-29T03:25:33.28-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248725!----QUIT----2025-08-29T03:25:44.921-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248962!----QUIT/NOSAVE----2025-08-29T21:02:37.813-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248962!----QUIT/NOSAVE----2025-08-29T21:02:37.831-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248962!----QUIT/NOSAVE----2025-08-29T21:02:51.96-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248962!----QUIT/NOSAVE----2025-08-29T21:02:51.975-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248962!----QUIT----2025-09-01T01:37:11.678-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 248962!----QUIT----2025-09-01T01:37:11.693-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 249584!----SNAPSHOT----2025-09-03T14:50:11.894-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 249703!----SNAPSHOT----2025-09-03T14:50:11.917-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 249822!----SNAPSHOT----2025-09-03T15:09:00.1-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 249945!----SNAPSHOT----2025-09-03T15:09:00.132-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 250068!----SNAPSHOT----2025-09-12T21:55:54.773-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 250189!----SNAPSHOT----2025-09-12T21:55:54.807-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 250312!----SNAPSHOT----2025-09-12T21:55:55.445-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 250435!----SNAPSHOT----2025-09-12T21:55:55.468-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 250558!----SNAPSHOT----2025-09-12T21:55:55.841-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 250681!----SNAPSHOT----2025-09-12T21:55:55.863-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 250804!----SNAPSHOT----2025-09-12T21:55:56.241-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 250927!----SNAPSHOT----2025-09-12T21:55:56.266-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 251050!----QUIT----2025-09-12T21:56:03.069-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 251173!----QUIT----2025-09-12T21:56:03.092-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 251296!----SNAPSHOT----2025-09-21T14:40:05.876-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 251415!----SNAPSHOT----2025-09-21T14:40:05.901-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 251534!----QUIT----2025-09-23T19:25:39.541-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 251657!----QUIT----2025-09-23T19:25:39.56-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 251780!----SNAPSHOT----2025-09-24T01:53:04.02-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 251899!----SNAPSHOT----2025-09-24T01:53:04.035-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252017!----QUIT----2025-09-24T01:53:08.403-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252139!----QUIT----2025-09-24T01:53:08.418-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252262!----SNAPSHOT----2025-09-28T22:02:06.375-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252381!----SNAPSHOT----2025-09-28T22:02:06.399-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252500!----SNAPSHOT----2025-10-01T15:15:12.893-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252623!----SNAPSHOT----2025-10-01T15:15:12.914-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252746!----QUIT----2025-10-01T15:15:17.047-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252869!----QUIT----2025-10-01T15:15:17.063-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 252992!----SNAPSHOT----2025-10-10T19:22:08.943-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 253111!----SNAPSHOT----2025-10-10T19:22:08.965-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 253230!----SNAPSHOT----2025-10-10T19:23:31.082-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 253353!----SNAPSHOT----2025-10-10T19:23:31.104-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 253476!----SNAPSHOT----2025-10-10T19:23:41.192-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 253599!----SNAPSHOT----2025-10-10T19:23:41.212-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 253722!----SNAPSHOT----2025-10-10T19:25:49.785-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 253845!----SNAPSHOT----2025-10-10T19:25:49.81-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 253968!----SNAPSHOT----2025-10-10T19:28:17.608-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 254091!----SNAPSHOT----2025-10-10T19:28:17.628-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 254213!----SNAPSHOT----2025-10-10T19:32:40.006-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 254336!----SNAPSHOT----2025-10-10T19:32:40.026-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 254459!----SNAPSHOT----2025-10-10T19:49:14.101-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 254582!----SNAPSHOT----2025-10-10T19:49:14.125-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 254705!----QUIT----2025-11-01T01:18:43.92-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 254828!----QUIT----2025-11-01T01:18:43.939-04:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 254951!----QUIT----2025-11-03T20:47:03.553-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 255069!----QUIT----2025-11-03T20:47:03.571-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 255188!!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-06T15:53:32.678-05:00' prior: 485101!mutiplyInverse [ 		| x  |	"scalculate the inverse of sourceMatrix - non-destructively 	 then multiply that by sourceMatrix and return true if the result is close to an identity matrix, else false "	x := sourceMatrix invert.						^ true .	 ].! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-06T19:06:25.623-05:00' prior: 511069!mutiplyInverse 		| x resultMatrix matrixLength identityMatrix|		super initialize.	"scalculate the inverse of sourceMatrix - non-destructively 	 then multiply that by sourceMatrix and return true if the result is close to an identity matrix, else false "	x := sourceMatrix invert.	    resultMatrix := x * sourceMatrix. 	"^ true if resultMatrix == identityMatrix." 					 .! !Benchmark << #BeMatrixInversion	slots: { #matrix . #sourceMatrix . #size , #resultMatrix };	tag: 'MatrixInversion';	package: 'ZagBench'!----SNAPSHOT----2025-11-06T19:07:01.746-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 255307!----SNAPSHOT----2025-11-06T19:07:01.768-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 256428!----SNAPSHOT----2025-11-06T19:07:02.253-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 256551!----SNAPSHOT----2025-11-06T19:07:02.271-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 256674!----SNAPSHOT----2025-11-06T19:07:02.485-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 256797!----SNAPSHOT----2025-11-06T19:07:02.498-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 256920!----SNAPSHOT----2025-11-06T21:08:39.595-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 257043!----SNAPSHOT----2025-11-06T21:08:39.624-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 257166!!BeMatrixInversion methodsFor: 'nil' stamp: '2025-11-08T16:42:18.728-05:00'!identityMatrix	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"		! !!BeMatrixInversion methodsFor: 'nil' stamp: '2025-11-08T19:35:50.167-05:00'!verifyMatrixInverse	"comment stating purpose of instance-side method"	"scope: class-variables  &  instance-variables"	! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-16T21:49:56-05:00' prior: 511797!mutiplyInverse 	| x resultMatrix |        x := sourceMatrix invert.     resultMatrix := x * sourceMatrix.         ^ self identityMatrix resultMatrix .		! !BeMatrixInversion removeSelector: #verifyMatrixInverse!!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-16T23:19:52.83-05:00' prior: 514981!identityMatrix| rows cols  | super initialize.rows := sourceMatrix rows.cols := sourceMatrix cols.		1 to: rows do: [ :i |        1 to: cols do: [ :j |            | value expected |            value := sourceMatrix at: i and: j.            expected := (i = j) ifTrue: [ 1 ] ifFalse: [ 0 ].        ]    ].        ^ true.! !BeMatrixInversion removeSelector: #partialPivoting!BeMatrixInversion removeSelector: #performGaussianElimination!BeMatrixInversion removeSelector: #swapRowsIfHigherRowsFound!BeMatrixInversion removeSelector: #extractInverseMatrix!BeMatrixInversion removeSelector: #createIdentityMatrix!BeMatrixInversion removeSelector: #createAugmentedMatrix!!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-16T23:47:49.484-05:00' prior: 516499!identityMatrix| rows columns  | super initialize.rows := sourceMatrix rows.columns := sourceMatrix columns.		1 to: rows do: [ :i |        1 to: columns do: [ :j |            | value expected |            value := sourceMatrix at: i and: j.            expected := (i = j) ifTrue: [ 1 ] ifFalse: [ 0 ].        ]    ].        ^ true.! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-16T23:48:34.268-05:00' prior: 515839!mutiplyInverse 	| x resultMatrix |        x := sourceMatrix invert.     resultMatrix := x * sourceMatrix.         ^ self identityMatrix: resultMatrix .			! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-16T23:52:45.765-05:00' prior: 518101!identityMatrix| rows columns  | super initialize.rows := sourceMatrix rows.columns := sourceMatrix columns.		1 to: rows do: [ :i |        1 to: columns do: [ :j |            | value expected |            value := sourceMatrix at: i and: j.            expected := (i = j) ifTrue: [ 1 ] ifFalse: [ 0 ].        ]    ].        ^ true.! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-16T23:55:52.045-05:00'!isIdentityMatrix: sourceMatrix | rows columns  | rows := sourceMatrix rows.columns := sourceMatrix columns.		1 to: rows do: [ :i |        1 to: columns do: [ :j |            | value expected |            value := sourceMatrix at: i and: j.            expected := (i = j) ifTrue: [ 1 ] ifFalse: [ 0 ].        ]    ].        ^ true.! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-16T23:56:42.877-05:00' prior: 520551!isIdentityMatrix: sourceMatrix | rows columns  | super initialize.rows := sourceMatrix rows.columns := sourceMatrix columns.		1 to: rows do: [ :i |        1 to: columns do: [ :j |            | value expected |            value := sourceMatrix at: i and: j.            expected := (i = j) ifTrue: [ 1 ] ifFalse: [ 0 ].        ]    ].        ^ true.! !!BeMatrixInversion methodsFor: 'as yet unclassified' stamp: '2025-11-16T23:56:50.604-05:00' prior: 521465!isIdentityMatrix: sourceMatrix | rows columns  |rows := sourceMatrix rows.columns := sourceMatrix columns.		1 to: rows do: [ :i |        1 to: columns do: [ :j |            | value expected |            value := sourceMatrix at: i and: j.            expected := (i = j) ifTrue: [ 1 ] ifFalse: [ 0 ].        ]    ].        ^ true.! !BeMatrixInversion removeSelector: #identityMatrix!----SNAPSHOT----2025-11-19T20:48:09.06-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 257289!----SNAPSHOT----2025-11-19T20:48:09.075-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 261606!----SNAPSHOT----2025-11-19T20:48:09.56-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 261728!----SNAPSHOT----2025-11-19T20:48:09.578-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 261851!----SNAPSHOT----2025-11-19T20:48:09.809-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 261973!----SNAPSHOT----2025-11-19T20:48:09.822-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 262096!!BeRandom methodsFor: 'random value creation' stamp: '2025-11-19T21:26:01.308-05:00' prior: 170763!randomWithRows: rows columns: cols	^ (1 to: rows) collect: [ :i |		  (1 to: cols) collect: [ :j | self next ] ]	! !BeRandom removeSelector: #extractInverseMatrix!----SNAPSHOT----2025-11-19T21:26:48.548-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 262219!----SNAPSHOT----2025-11-19T21:26:48.564-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 262612!----SNAPSHOT----2025-11-19T23:14:08.499-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 262735!----SNAPSHOT----2025-11-19T23:14:08.516-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 262858!----QUIT----2025-11-19T23:18:06.944-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 262981!----QUIT----2025-11-19T23:18:06.962-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 263104!----SNAPSHOT----2025-12-06T20:22:12.491-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 263223!----SNAPSHOT----2025-12-06T20:22:12.509-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 263342!----SNAPSHOT----2025-12-06T23:10:00.317-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 263465!----SNAPSHOT----2025-12-06T23:10:00.364-05:00 Pharo 13.0 - 64bit (development version, latest).image priorSource: 263588!Object << #MonticelloBrowser	layout: FixedLayout;	traits: {};	slots: {};	sharedVariables: {};	sharedPools: {};	tag: 'Objects' ;	package: 'Kernel'!